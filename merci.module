<?php


/**
 * @file
 * MERCI - Managed Equipment Reservation Checkout and Inventory
 */


define('MERCI_STATUS_FIELD', 'field_merci_status');
define('MERCI_ITEM_STATUS_FIELD', 'field_merci_item_status');
define('MERCI_ROLE_FIELD', 'field_merci_role_permission');

define('MERCI_STATUS_UNCONFIRMED', 0);
define('MERCI_STATUS_PENDING', 1);
define('MERCI_STATUS_CHECKED_OUT', 2);
define('MERCI_STATUS_CHECKED_IN', 3);
define('MERCI_STATUS_CANCELLED', 4);
define('MERCI_STATUS_DENIED', 5);
define('MERCI_STATUS_NO_SHOW', 6);

define('MERCI_DISABLED', 'disabled');
define('MERCI_BUCKET', 'bucket');
define('MERCI_RESOURCE', 'resource');
define('MERCI_RESERVATION', 'reservation');


#module_load_include('inc', 'merci', 'includes/database');
#module_load_include('inc', 'merci', 'includes/api');
module_load_include('inc', 'merci', 'includes/merci.workflow');

module_load_include('inc', 'merci', 'includes/reservation.handler');

function merci_get_controller($entity_type, $entity, $date_field, $target_field) {
  $controllers = &drupal_static(__FUNCTION__, array());
  if (!isset($controllers[$entity_type])) {
    $class = 'MerciDefaultReservationController'; 
    if (class_exists($class)) {
      $controllers[$entity_type] = call_user_func(array($class, 'getInstance'), $entity_type, $entity, $date_field, $target_field);
    }
  }
  return $controllers[$entity_type];
}

/**
 * Implements hook_permission().
 */
function merci_permission() {
  return array(
    'create reservations' => array(
      'title' => t('create reservations'),
      'description' => t('TODO Add a description for \'create reservations\''),
    ),
    'create confirmed reservations' => array(
      'title' => t('create confirmed reservations'),
      'description' => t('TODO Add a description for \'create confirmed reservations\''),
    ),
    'suspend MERCI access' => array(
      'title' => t('suspend MERCI access'),
      'description' => t('TODO Add a description for \'suspend MERCI access\''),
    ),
    'administer MERCI' => array(
      'title' => t('administer MERCI'),
      'description' => t('TODO Add a description for \'administer MERCI\''),
    ),
    'create reservations outside hours of operation' => array(
      'title' => t('create reservations outside hours of operation'),
      'description' => t('TODO Add a description for \'create reservations outside hours of operation\''),
    ),
    'manage reservations' => array(
      'title' => t('manage reservations'),
      'description' => t('TODO Add a description for \'manage reservations\''),
    ),
    'override max hours over closed days' => array(
      'title' => t('override max hours over closed days'),
      'description' => t('TODO Add a description for \'override max hours over closed days\''),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function merci_menu() {


  $items['merci/taxonomy/%node/%/%'] = array(
    'title' => 'JSON interface for node taxonomy',
    'description' => 'Takes a node ID and returns taxonomy data as JSON',
    'page callback' => 'merci_taxonomy_json',
    'access arguments' => array('manage reservations'),
    'page arguments' => array(2, 3, 4),
    'file' => 'includes/menu.inc',
    'type' => MENU_CALLBACK,
  );


  // Adds Manage Equipment to Admin Interfaces
  //
  $items['admin/merci/manage'] = array(
    'title' => 'Manage Equipment',
    'description' => 'Manage Equipment Reservations, Checkout and Inventory (MERCI)',
    'position' => 'right',
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array('manage reservations'),
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
    'weight' => -19,
  );

  $items['admin/merci/manage/current_inventory'] = array(
    'title' => 'Current Inventory',
    'description' => 'Displays list',
    'page callback' => 'theme',
    'page arguments' => array('merci_current_inventory'),
    'access arguments' => array('manage reservations'),
    'type' => MENU_NORMAL_ITEM,
  );

  $items['admin/merci/manage/current_inventory/%'] = array(
    'title' => 'Current Inventory',
    'description' => 'Displays list',
    'type' => MENU_CALLBACK,
  );

  // Standard Administration settings.
  $items['admin/config/system/merci'] = array(
    'title' => 'MERCI Configuration',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('merci_admin_settings'),
    'access callback' => 'user_access',
    'access arguments' => array('administer MERCI'),
    'description' => 'Configure system settings for MERCI.',
    'file' => 'includes/merci.admin.inc',
  );

  $items['admin/config/system/merci/edit'] = array(
    'title' => 'Edit',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  return $items;
}

/**
 * Implements hook_node_info().
 */
function merci_node_info() {
  return array(
    // Reservation nodes.
    'merci_reservation' => array(
      'name' => t('Reservation'),
      'base' => 'merci',
      'has_body' => FALSE,
      'description' => t("A reservation reserves a resource or group of resources for some period of time."),
    ),
  );
}

/**
 * Implements hook_node_access().
 */
function merci_node_access($node, $op, $account) {
  global $user;

  $type = isset($node->type) ? $node->type : $node;
  $uid = isset($node->uid) ? $node->uid : FALSE;

  // Only allow authors to delete reservations if the reservation is unconfirmed.
  if ($type == 'merci_reservation') {
    if ($op == 'delete' and $account->uid == $uid and !user_access('manage reservations', $account)) {
      $offset = variable_get('merci_workflow_state_offset', 0);
      if ($node->{MERCI_STATUS_FIELD}['und'][0]['value'] > MERCI_STATUS_UNCONFIRMED + $offset) {
        return NODE_ACCESS_DENY;
      }
    }
  }
}

function merci_field_access($op, $field, $entity_type, $entity, $account) {

  // Disallow users from editing date and items for confirmed reservations.
  if (!$entity 
    or !property_exists($entity, 'type') 
    or $entity->type != 'merci_reservation' 
    or $op != 'edit' 
    or !property_exists($entity, MERCI_STATUS_FIELD)
    or ($field['field_name'] != 'field_merci_date' and $field['field_name'] != 'merci_reservation_items')
    or user_access('manage reservations', $account)) 
  {
    return TRUE;
  }

  $offset = variable_get('merci_workflow_state_offset', 0);

  if ($entity->{MERCI_STATUS_FIELD}['und'][0]['value'] > MERCI_STATUS_UNCONFIRMED + $offset) {
    return FALSE;
  }
  return TRUE;
}

/**
 * Implementation of hook_validate().
 */
function merci_reservation_node_validate($form, &$form_state) {

  if (!empty($form_state['ahah_submission'])) {
    return;
  }

  // No validation necessary on deletion.
  if ($form_state['triggering_element']['#id'] == 'edit-delete') {
    return;
  }

  // Do no validation if their errors from the main validation function.
  if (form_get_errors()) {
    return;
  }

  merci_validate_status($form, $form_state);
  merci_validate_merci_reservation_date($form, $form_state);

  // Tests for existing items.
  //  merci_validate_empty_reservation_items($form, $form_state);
  merci_validate_merci_selected_items($form, $form_state);
}


/**
 * Implementation of hook_form().
 */
function merci_form($node, &$form_state) {

  $form = node_content_form($node, $form_state);

  // Since hook_validate is broken in 6.x, we add our own
  // custom validation here.
  // TODO check if this fixed.
  $form['#validate'][] = 'merci_validate_merci_selected_items';
  $form['#validate'][] = 'merci_workflow_validate_items';
  $form['#validate'][] = 'merci_permissions_validate_items';
  $form['#validate'][] = 'merci_validate_unique_items';

  $form['#cache'] = TRUE; // Make sure the form is cached.

  // Pull the correct action out of form_state if it's there to avoid AHAH+Validation action-rewrite.
  if (isset($form_state['action'])) {
    $form['#action'] = $form_state['action'];
  }

  return $form;
}

function merci_validate_unique_items($form, &$form_state) {

  $node = (object) $form_state['values'];

  $entity_type  = 'node';

  $entity       = entity_metadata_wrapper($entity_type, $node);

  $target_field = 'merci_reservation_items';
  $field_info = field_info_field($target_field);
  $target_type = $field_info['settings']['target_type'];

  $ids = array();
  foreach ($entity->{$target_field}->raw() as $delta => $target_id) {
    if (!empty($target_id) and intval($target_id)) {
      $ids[$delta] = $target_id;
    }
  }
  $unique = array_unique($ids);
  if (count($ids) != count($unique)) {
    foreach ($ids as $delta => $target_id) {
      if (!array_key_exists($delta, $unique)) {
        $targets = entity_load($target_type, array($target_id));
        $messages[$delta] = t('%title is overbooked.  You can only reserve one of this item.', array('%title' => $targets[$target_id]->title)); 
        form_set_error("merci_reservation_items][und][$delta][target_id", $messages[$delta]);
      }
    }
  }
  //form_set_error('', 'error');
}

function merci_permissions_validate_items($form, &$form_state) {

  $node = (object) $form_state['values'];

  $entity_type  = 'node';

  $entity       = entity_metadata_wrapper($entity_type, $node);

  $target_field = 'merci_reservation_items';
  $field_info = field_info_field($target_field);
  $target_type = $field_info['settings']['target_type'];

  $ids = array();
  foreach ($entity->{$target_field}->raw() as $delta => $target_id) {
    if (!empty($target_id) and intval($target_id)) {
      $ids[] = $target_id;
    }
  }
  $targets = entity_load($target_type, $ids);
  $account = user_load($node->uid);
  $user_roles = array_keys($account->roles);

  foreach ($entity->{$target_field}->raw() as $delta => $target_id) {
    if (!empty($target_id) and intval($target_id)) {
      $target = entity_metadata_wrapper($target_type, $targets[$target_id]);
      $roles = $target->{MERCI_ROLE_FIELD}->raw();
      if(!count(array_intersect($roles, $user_roles))) {
        $messages[$delta] = t('User %user does not have permission to reserve %title.', array('%user' => $account->name, '%title' => $targets[$target_id]->title)); 
        form_set_error("merci_reservation_items][und][$delta][target_id", $messages[$delta]);
      }
    }
  }
}

function merci_validate_merci_selected_items($form, &$form_state) {
  $node = (object) $form_state['values'];

  $entity_type  = 'node';

  $entity       = entity_metadata_wrapper($entity_type, $node);

  $date_field   = 'field_merci_date';
  $target_field = 'merci_reservation_items';
  $status_field = MERCI_STATUS_FIELD;

  $field_info = field_info_field($target_field);
  $target_type = $field_info['settings']['target_type'];

  if ($entity->{MERCI_STATUS_FIELD}->value() > MERCI_STATUS_CHECKED_OUT) {
    return;
  }

  //TODO do not validate if status is greater then MERCI_STATUS_CHECKED_OUT.
  $controller = merci_get_controller($entity_type, $entity, $date_field, $target_field);
  $ids =  $controller->conflictingTargets();

  $conflicts = entity_load($target_type, $ids);

  foreach ($entity->{$target_field}->raw() as $delta => $target_id) {
    if (in_array($target_id, $ids)) {
      $messages[$delta] = t('%title is not available at this time.', array('%title' => $conflicts[$target_id]->title)); 
      form_set_error("merci_reservation_items][und][$delta][target_id", $messages[$delta]);
    }
  }
}

function merci_taxonomy_term_select($title, $name, $value, $vocabulary_id, $description, $multiple, $blank, $exclude = array()) {
  $tree = taxonomy_get_tree($vocabulary_id);
  $options = array();

  if ($blank) {
    $options[''] = $blank;
  }
  if ($tree) {
    foreach ($tree as $term) {
      if (!in_array($term->tid, $exclude)) {
        $choice = new stdClass();
        $choice->option = array($term->tid => str_repeat('-', $term->depth) . $term->name);
        $options[] = $choice;
      }
    }
  }

  return array(
    '#type' => 'select', 
    '#title' => $title, 
    '#default_value' => $value, 
    '#options' => $options, 
    '#description' => $description, 
    '#multiple' => $multiple, 
    '#size' => $multiple ? min(9, count($options)) : 0, 
    '#weight' => -15, 
  );
}

/**
 * Implementation of hook_form_alter().
 */
function merci_form_alter(&$form, $form_state, $form_id) {

  // Node add/edit forms.

  $type = (isset($form['#bundle'])) ? $form['#bundle'] : NULL;

  switch ($form_id) {
    // Node settings form.

  case 'merci_reservation_node_form':
    $form['field_merci_date']['field_merci_date_button'] = array(
      '#type' => 'submit',
      '#value' => t('Limit Lists to Available Items'),
      //'#weight' => $weight,
      '#submit' => array('merci_date_filter'),
      '#limit_validation_errors' => array(array('merci_reservation_items'), array('choice_count'), array('field_merci_date')),  // No need to validate when submitting this.
      '#validate' => array(),
      '#ajax' => array(
        //'path' => 'merci/js',
        'callback' => 'merci_choice_js',
        'wrapper' => 'merci-choice-wrapper',
        'method' => 'replace',
        'effect' => 'fade',
      ),
    );
    return;
  case $type . '_node_form':
    return;
    if (merci_is_merci_type($type)) {

      $node = (object) $form['#node'];

      $sub_type = isset($node->merci_sub_type) ? $node->merci_sub_type : MERCI_SUB_TYPE_ITEM;

      if ($sub_type == MERCI_SUB_TYPE_ITEM) {
        if (empty($form['merci'])) {
          $form['merci'] = array(
            '#type' => 'fieldset',
            '#title' => t('MERCI settings'),
            '#collapsible' => TRUE,
            '#collapsed' => TRUE,
            '#group' => 'additional_settings',
          );
        }
      }
      $form['merci_sub_type'] = array(
        '#type' => 'value',
        '#value' => $sub_type,
      );

      merci_add_settings_form($form, $form_state);
    }
    break;

  case 'node_delete_confirm':
    $node = node_load((int) arg(1));
    if (!merci_delete_item_validate($node)) {
      unset($form['actions']['submit']);
    }
    break;

  case 'node_type_delete_confirm':
    $type = str_replace('-', '_', arg(3));
    merci_delete_node_type_validate($form);
    break;

  case 'node_admin_content':
    if (!isset($form['#validate'])) {
      $form['#validate'] = array();
    }
    $form['#validate'][] = 'merci_node_admin_delete_validate';
    break;
  }
}

/**
 * Validates saving of MERCI node types.
 */
function merci_node_type_save_validate($form, &$form_state) {
  $values = $form_state['values'];
  return;
  // Only validate node types set to an inactive status.
  if ($values['merci_type_setting'] != 'disabled' && (int) $values['merci_active_status'] == MERCI_STATUS_INACTIVE) {
    // Determine CCK table and columns the date data is stored in.
    $field = field_info_field('field_merci_date');
    $table           = key($field['storage']['details']['sql']['FIELD_LOAD_CURRENT']);
    $column_end_date = $field['storage']['details']['sql']['FIELD_LOAD_CURRENT'][$table]['value2'];

    $time = gmdate('Y-m-d H:i:s');
    $type_setting = $values['merci_type_setting'];

    // Pull all active reservations that use the node type.
    // TODO Please convert this statement to the D7 database API syntax.
    $reservations = db_query("SELECT ctn.nid, ctn.title FROM {" . $table . "} ct INNER JOIN {merci_reservation_detail} md ON ct.revision_id = md.vid INNER JOIN {node} ctn ON ct.revision_id = ctn.vid INNER JOIN {merci_{$type_setting}_node} m ON md.merci_placeholder_nid = m.nid INNER JOIN {node} mn ON m.vid = mn.vid  WHERE mn.type = :type AND m.merci_sub_type = :merci_sub_type AND $column_end_date >= :end AND NOT (md.merci_item_status <= :merci_item_status)", 
      array(
        ':type' => $values['old_type'], 
        ':merci_sub_type' => MERCI_SUB_TYPE_RESERVATION, 
        ':end' => $time, 
        ':merci_item_status' => MERCI_ITEM_STATUS_CHECKED_IN
      )
    );

    $bad_reservations = array();
    foreach ($reservations as $reservation) {
      $bad_reservations[] = l($reservation->title, "node/$reservation->nid/edit", array('query' => drupal_get_destination()));
    }

    if (!empty($bad_reservations)) {
      form_set_error('merci_active_status', t('@type_setting can not be set to an inactive status until all @type_setting items are removed from the following reservations:', array('@type_setting' => $type_setting)) . theme('item_list', array('items' => $bad_reservations)));
    }
  }
}

/**
 * Implementation of hook_node_operations().
 */
function merci_node_operations($return = NULL) {
  $operations = array(
    'merci_update' => array(
      'label' => t('Confirm Reservation(s)'),
      'callback' => 'merci_operations_update',
    ),
  );
  return $operations;
}

/**
 * Implementation of hook_views_api().
 */
function merci_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'merci'),
  );
}

/**
 * Implementation of hook_views_handlers().
 */
/**
 * Implementation of hook_cron().
 */
function merci_cron() {

  return;
  // 2009-05-22 20:45:00
  $time = gmdate('Y-m-j H:i:s');

  $nodes = merci_db_reservations_by_status_in_timespan(array(MERCI_STATUS_UNCONFIRMED, MERCI_STATUS_PENDING), $time, $time);

  foreach (array_keys($nodes) as $reservation_nid) {

    $reservation = node_load($reservation_nid);

    //check child items of that reservations for autocheckout
    foreach ($reservation->merci_reservation_items as $item) {
      $node = node_load($item['merci_item_nid']);
      if (!$node or !$node->merci_autocheckout) {
        // skip out to the next reservation.
        continue 2;
      }
    }

    //after checking all of the autocheckout settings for all the child items, are they all autocheckout?
    watchdog('merci', "Setting node @reservation_nid to checked out", array('@reservation_nid' => $reservation_nid));
    $reservation->merci_reservation_status = MERCI_STATUS_CHECKED_OUT;
    node_save($reservation);
  }

  $nodes = merci_db_reservations_by_status_in_timespan(array(MERCI_STATUS_CHECKED_OUT), NULL, $time, TRUE);

  foreach (array_keys($nodes) as $reservation_nid) {

    //check child items of that reservations for autocheckin
    $reservation = node_load($reservation_nid);

    foreach ($reservation->merci_reservation_items as $item) {
      $node = node_load($item['merci_item_nid']);
      if (!$node or !$node->merci_autocheckin) {
        // skip out to the next reservation.
        continue 2;
      }
    }

    //after checking all of the autocheckout settings for all the child items, are they all autocheckout?
    watchdog('merci', "Setting node @reservation_nid to checked in", array('@reservation_nid' => $reservation_nid));
    $reservation->merci_reservation_status = MERCI_STATUS_CHECKED_IN;
    node_save($reservation);
  }

  // Give no shows a one hour grace period.
  // TODO: move grace period to admin option.
  // 2009-05-22 20:45:00
  $time = gmdate('Y-m-j H:i:s', time() - 3600);
  //find all pending reservations that have started and set their stauts to no show
  $nodes = merci_db_reservations_by_status_in_timespan(array(MERCI_STATUS_PENDING), $time, NULL);

  foreach (array_keys($nodes) as $reservation_nid) {
    watchdog('merci', "Setting node @reservation_nid to no show", array('@reservation_nid' => $reservation_nid));
    $node = node_load($reservation_nid);
    $node->merci_reservation_status = MERCI_STATUS_NO_SHOW;
    node_save($node);
  }
}

/**
 * Implements hook_theme().
 */
function merci_theme() {
  return array(
    'merci_build_reservation_table_form2' => array(
      'render element' => 'form',
      'path' => drupal_get_path('module', 'merci') . '/theme',
      'theme path' => drupal_get_path('module', 'merci') . '/theme',
      'file' => 'theme.inc',
    ),
    'merci_reservation_table' => array(
      'template' => 'merci_reservation_table',
      'path' => drupal_get_path('module', 'merci') . '/theme',
      'variables' => array(
        'reservations' => NULL,
        'count' => NULL,
        'hours' => NULL,
        'title' => NULL,
      ),
    ),
    'merci_current_inventory' => array(
      'path' => drupal_get_path('module', 'merci') . '/theme',
      'file' => 'theme.inc',
    ),
  );
}

/**
 * Implements hook_simpletest().
 */
function merci_simpletest() {
  $dir = drupal_get_path('module', 'merci') . '/tests';
  $tests = file_scan_directory($dir, '/\.test$/');
  return array_keys($tests);
}


function _merci_content_type_info($reset = FALSE) {
  static $info;
  if ($reset || !isset($info)) {
    if (!$reset && $cached = cache_get('merci_content_type_info')) {
      $info = $cached->data;
    }
    else {
      $info = array();
      // Load MERCI node type settings.
      $merci_settings = db_query("SELECT * FROM {merci_node_type} mt INNER JOIN {node_type} nt ON mt.type = nt.type WHERE merci_type_setting <> :merci_type_setting", array(':merci_type_setting' => 'disabled'));
      // with the correct stuff..
      foreach ($merci_settings as $merci_setting) {
        $merci_setting = (array) $merci_setting;
        $merci_setting['type_name'] = $merci_setting['name'];
        $grouping = $merci_setting['merci_type_setting'] == 'resource' ? $merci_setting['type_name'] : t('Buckets');
        $tid = variable_get('merci_grouping_' . $merci_setting['type'], 0);
        if ($tid) {
          $term = taxonomy_term_load($tid);
          if ($term) {
            $grouping = $term->name;
          }
        }
        $merci_setting['merci_item_grouping'] = $grouping;
        unset($merci_setting['name']);
        $info[$merci_setting['type']] = $merci_setting;
      }
      cache_set('merci_content_type_info', $info);
    }
  }
  return $info;
}

/**
 * Custom validation function to protect merci nodes from mass deletion.
 */
function merci_node_admin_delete_validate($form, &$form_state) {

  // Look only for delete op.
  $operation = $form_state['values']['operation'];
  if ($operation != 'delete') {
    return;
  }
  // Get the checked nodes.
  $nids = array_filter($form_state['values']['nodes']);

  // Perform the check for each submitted node.
  foreach ($nids as $nid) {
    $node = node_load($nid);

    // Check to see if any of the nodes should not be deleted.
    if (!merci_delete_item_validate($node)) {
      // If so, then unset the checked node so it will not be processed, and display a warning.
      // Note that the array element has to be completely removed here in order to prevent the
      // node from being deleted, due to the nature of the mass deletion callback.
      unset($form_state['values']['nodes'][$nid]);
      unset($nids[$nid]);
    }
  }

  // If we've unset all of the nodes that were checked, then don't continue with the form processing.
  if (!count($nids)) {
    drupal_set_message(t('No nodes selected.'), 'error');
    drupal_goto('admin/content/node');
  }
}

/**
 * Validates if an item node can be deleted.
 *
 * @param $node
 *   The item node.
 * @param $single
 *   TRUE if a single item node deletion is being processed, FALSE otherwise.
 *
 * @return
 *   TRUE if the item can be deleted, FALSE otherwise.
 */
function merci_delete_item_validate($node) {
  // Only validate bucket/resource items.
  if ($node->type != 'merci_reservation' && isset($node->merci_type_setting) && $node->merci_type_setting != 'disabled' && isset($node->merci_sub_type) && $node->merci_sub_type == MERCI_SUB_TYPE_ITEM) {
    // Determine CCK table and columns the date data is stored in.
    $field = field_info_field('field_merci_date');
    $table           = key($field['storage']['details']['sql']['FIELD_LOAD_CURRENT']);

    // Join on nid here so that any version of the reservation that contain
    // the item is caught.
    // Pull any reservations that use the item in question
    // TODO Please convert this statement to the D7 database API syntax.
    $reservations = db_query("SELECT n.nid, n.title FROM {node} n INNER JOIN {" . $table . "} ct ON ct.revision_id = n.vid INNER JOIN {merci_reservation_detail} md ON ct.revision_id = md.vid WHERE md.merci_item_nid = :merci_item_nid", array(':merci_item_nid' => $node->nid));

    $bad_reservations = array();
    foreach ($reservations as $reservation) {
      // Key by nid to prevent duplicate revisions from appearing.
      $bad_reservations[$reservation->nid] = l($reservation->title, "node/$reservation->nid/edit", array('query' => drupal_get_destination()));
    }

    if (!empty($bad_reservations)) {
      drupal_set_message(t('%title can not be deleted, because it is associated with the following reservations:', array('%title' => $node->title)) . theme('item_list', array('items' => $bad_reservations)), 'error');
      // Lock out single deletion attempts here.
      return FALSE;
    }
  }

  return TRUE;
}

/**
 * Validates deletion of node types.
 *
 * @param $type
 *   The type being deleted.
 */
function merci_delete_node_type_validate(&$form) {

  $type = $form['type']['#value'];
  // Only validate active MERCI node types.
  if (merci_is_merci_type($type)) {
    //$settings = merci_load_item_settings($type);
    $merci_type_setting = merci_type_setting($type);

    // Determine CCK table and columns the date data is stored in.
    $field = field_info_field('field_merci_date');
    $table           = key($field['storage']['details']['sql']['FIELD_LOAD_CURRENT']);

    // Join on nid here so that any version of the reservation that contain
    // the bucket/resource is caught.
    // TODO Please convert this statement to the D7 database API syntax.
    $reservations = db_query("SELECT ctn.nid, ctn.title FROM {" . $table . "} ct INNER JOIN {merci_reservation_detail} md ON ct.revision_id = md.vid INNER JOIN {node} ctn ON ct.entity_id = ctn.nid INNER JOIN {merci_{$merci_type_setting}_node} m ON md.merci_placeholder_nid = m.nid INNER JOIN {node} mn ON m.vid = mn.vid  WHERE mn.type = :type AND m.merci_sub_type = :merci_sub_type ORDER BY ct.entity_id, ct.revision_id", 
      array(
        ':type' => $type, 
        ':merci_sub_type' => MERCI_SUB_TYPE_RESERVATION
      )
    );

    $bad_reservations = array();
    foreach ($reservations as $reservation) {
      $bad_reservations[$reservation->nid] = l($reservation->title, "node/$reservation->nid/edit", array('query' => drupal_get_destination()));
    }

    if (!empty($bad_reservations)) {
      $name = node_type_get_name($type);
      drupal_set_message(t('@type can not be deleted because it is associated with the following reservations:', array('@type' => $name)) . theme('item_list', array('items' => $bad_reservations)), 'error');
      unset($form['actions']['submit']);
    }
  }
}

// TODO: should not do theming in validation funcitons.
/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function merci_theme_conflict_grid($controller) {
  return theme('merci_conflict_grid', array('controller' => $controller));
}
/**
 * Builds the form item for the status display.
 *
 * @param $form_state
 *   Current form state.
 * @param $status
 *   Current status
 *
 * @return
 *   The form array.
 */
function merci_display_reservation_status($status) {
  return array(
    '#type' => 'item',
    '#title' => t('Status'),
    '#markup' => $status,
  );
}

function merci_build_accessory_form($form_state, $node, $did) {

  $vocabularies = taxonomy_get_vocabularies($node->type);

  $form = array();

  foreach ($node->taxonomy as $tid => $term) {
    $value[] = $tid;
  }
  foreach ($vocabularies as $vocabulary) {

    $taxonomy_form   = taxonomy_form($vocabulary->vid, $value);
    $taxonomy_form['#title'] = '';
    unset($taxonomy_form['#theme']);
    $taxonomy_form['#ajax'] = array(
      'path' => 'merci/taxonomy/' . $node->nid . '/' . $vocabulary->vid . '/' . $did,
      'wrapper' => 'merci-accessories-' . $node->nid,
      'method' => 'prepend',
      'effect' => 'fade',
    );
    $form[$vocabulary->vid] = $taxonomy_form;
  }
  return $form;
}


function merci_add_settings_form(&$form, $form_state) {

  // Only admin can edit these values.
  if (!user_access('administer MERCI')) {
    return;
  }

  $type = array_key_exists('old_type', $form) ? $form['old_type']['#value'] : $form['type']['#value'];
  //$merci_settings = mnerci_content_types($type);
  //if(!$merci_settings) return;
  if ($form['#id'] == 'node-type-form') {
    $node = merci_load_item_settings($type);
    $node = (object) $node;
  }
  else {
    $node = (object) $form['#node'];
  }
  //merci_load_item_settings($node);
  // New nodes are always sub type item.
  $sub_type = isset($node->merci_sub_type) ? $node->merci_sub_type : MERCI_SUB_TYPE_ITEM;
  $type_setting = isset($node->merci_type_setting) ? $node->merci_type_setting : NULL;

  if (empty($form['merci'])) {
    $form['merci'] = array(
      '#type' => 'fieldset',
      '#title' => t('MERCI settings'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#group' => 'additional_settings',
      '#attached' => array(
        'js' => array(drupal_get_path('module', 'menu') . '/menu.admin.js'),
      ), 
    );
  }

  $warning = '';
  if ($type_setting == 'resource' and $form['#id'] == 'node-type-form') {
    $warning  = '<div>' . t('<strong> WARNING:</strong> changing this setting has no effect on existing reserved items.') . '</div>';
  }

  // Bucket item nodes have no individual pricing, so just zero these values out.
  // Althought you can override them on the reserervation nodes.
  if ($type_setting == 'resource' or $form['#id'] == 'node-type-form' or $sub_type == MERCI_SUB_TYPE_RESERVATION ) {
    $form['merci']['merci_rate_per_hour'] = array(
      '#type' => 'textfield',
      '#title' => t('Rate per hour'),
      '#size' => 10,
      '#default_value' => isset($node->merci_rate_per_hour) ? $node->merci_rate_per_hour : NULL,
      '#element_validate' => array('merci_is_numeric_validate'),
      '#description' => t('The per hour rental fee for the item. !warning', array('!warning' => $warning)),
    );
    $form['merci']['merci_late_fee_per_hour'] = array(
      '#type' => 'textfield',
      '#title' => t('Late fee per hour'),
      '#size' => 10,
      '#default_value' => isset($node->merci_late_fee_per_hour) ? $node->merci_late_fee_per_hour : NULL,
      '#element_validate' => array('merci_is_numeric_validate'),
      '#description' => t('The per hour fee for returning the item late.') . $warning,
    );
    $form['merci']['merci_fee_free_hours'] = array(
      '#type' => 'textfield',
      '#title' => t('Fee free hours'),
      '#size' => 10,
      '#default_value' => isset($node->merci_fee_free_hours) ? $node->merci_fee_free_hours : NULL,
      '#element_validate' => array('merci_is_numeric_validate'),
      '#description' => t('The number of hours the item can be used before fees are charged.') . $warning,
    );
  }

  if (($type_setting  == 'resource' and $sub_type == MERCI_SUB_TYPE_ITEM) or $form['#id'] == 'node-type-form') {

    $form['merci']['merci_min_cancel_hours'] = array(
      '#type' => 'textfield',
      '#title' => t('Minimum hours for cancelation without No Show'),
      '#size' => 10,
      '#default_value' => isset($node->merci_min_cancel_hours) ? $node->merci_min_cancel_hours : NULL,
      '#element_validate' => array('merci_is_numeric_validate'),
      '#description' => t('Minimum number of hours before the start time a user may cancel a reservation for the item.') . $warning,
    );
    $form['merci']['merci_autocheckout'] = array(
      '#type' => 'checkbox',
      '#title' => t('Auto checkout'),
      '#default_value' => isset($node->merci_autocheckout) ? $node->merci_autocheckout : NULL,
      '#description' => t('Automatically check this item out when the Reservation starts.') . $warning,
    );
    $form['merci']['merci_autocheckin'] = array(
      '#type' => 'checkbox',
      '#title' => t('Auto checkin'),
      '#default_value' => isset($node->merci_autocheckin) ? $node->merci_autocheckin : NULL,
      '#description' => t('Automatically check this item in when the Reservation ends.') . $warning,
    );
    $form['merci']['merci_selfcheckout'] = array(
      '#type' => 'checkbox',
      '#title' => t('Self checkout'),
      '#default_value' => isset($node->merci_selfcheckout) ? $node->merci_selfcheckout : NULL,
      '#description' => t('Manage checkout with additional code.') . $warning,
    );
  }
}

function merci_form_node_type_form_alter(&$form, &$form_state, $form_id) {
  // Reservation content type can't used for other MERCI functionality.
  if (isset($form['#node_type']->type) && $form['#node_type']->type == 'merci_reservation') {
    return;
  }

  $type     = $form['old_type']['#value'];

  $merci_type = merci_type_setting($type);

  $options  = array(
    MERCI_DISABLED => t('Disabled'),
    MERCI_BUCKET => t('Bucket'),
    MERCI_RESOURCE => t('Resource'),
  );

  $form['merci']       = array(
    '#type' => 'fieldset',
    '#title' => t('MERCI settings'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#group' => 'additional_settings',
    '#attached' => array(
      'js' => array(drupal_get_path('module', 'menu') . '/menu.admin.js'),
    ), 
  );

  $description_items = array(
    MERCI_DISABLED => t('This content type cannot be reserved'),
    MERCI_RESOURCE => t('Use this content type to create unique items that can be reserved.'),
    MERCI_BUCKET   => t('Use this content type to create interchangeable items that can be reserved (ex. Camera). Buckets reference interchangeable items. The actual item does not have to be chosen until the reservation is checked out.'),
  );

  $form['merci']['merci_type_setting'] = array(
    '#type' => 'radios',
    '#title' => t('Reservable item type'),
    '#options' => $options,
    '#default_value' => $merci_type,
    '#description_items' => $description_items,
    '#after_build' => array('merci_type_setting_after_build'),
  );
  return;


  // This setting is only valid for buckets.
  if (!isset($settings->merci_type_setting) || $settings->merci_type_setting == 'bucket') {
    $form['merci']['merci_spare_items'] = array(
      '#type' => 'textfield',
      '#title' => t('Spare items'),
      '#size' => 10,
      '#default_value' => isset($settings->merci_spare_items) ? $settings->merci_spare_items : 0,
      '#element_validate' => array('merci_is_numeric_validate'),
      '#description' => filter_xss(t("Set this to the number of items of this type that should always be unavailable and thus unreservable.  This way you'll still have enough items for future reservations in case something breaks.") . $warning),
    );
    $form['merci']['merci_auto_assign_bucket_item'] = array(
      '#type' => 'checkbox',
      '#title' => t('Automatically assign a bucket item'),
      '#default_value' => isset($settings->merci_auto_assign_bucket_item) ? $settings->merci_auto_assign_bucket_item : 0,
      '#description' => t('Automatically assign the best fit bucket item when reserving a new bucket item.'),
    );
  }

  $vid = variable_get('merci_equipment_grouping_vid', 0);

  $form['merci']['merci_grouping'] = merci_taxonomy_term_select(
    t('Grouping'),
    NULL,
    variable_get('merci_grouping_' . $type, 0),
    $vid,
    t('This will alter order the content types are displayed to users reserving items from buckets.  Terms added to the MERCI Equipment Groupings taxonomy will appear here.'),
    0,
    t('<Select>')
  );

  $form['merci']['merci_max_hours_per_reservation'] = array(
    '#type' => 'textfield',
    '#title' => t('Maximum hours per reservation'),
    '#size' => 10,
    '#default_value' => isset($settings->merci_max_hours_per_reservation) ? $settings->merci_max_hours_per_reservation : 0,
    '#element_validate' => array('merci_is_numeric_validate'),
    '#description' => filter_xss(t('The maximum hours the item can be reserved for in one reservation. Set to zero for no limit.') . $warning),
  );
  $form['merci']['merci_allow_overnight'] = array(
    '#type' => 'checkbox',
    '#title' => t('Allow overnight reservation'),
    '#default_value' => isset($settings->merci_allow_overnight) ? $settings->merci_allow_overnight : 0,
    '#description' => filter_xss(t('Allow a reservation to continue over multiple days.  If this is not checked, items in this content type must be returned before the checkout closes.') . $warning),
  );
  $form['merci']['merci_allow_weekends'] = array(
    '#type' => 'checkbox',
    '#title' => t('Allow weekend reservation'),
    '#default_value' => isset($settings->merci_allow_weekends) ? $settings->merci_allow_weekends : 0,
    '#description' => filter_xss(t('Allow a reservation to be made over days defined as weekend.') . $warning),
  );

  merci_add_settings_form($form, $form_state);

  $form['#validate'][] = 'merci_node_type_save_validate';
  //$form['#submit'][]   = 'merci_node_type_save_submit';

}

function merci_type_setting_after_build($element) {
  foreach ($element['#description_items'] as $key => $value) {
    $element[$key]['#description'] = $value;
  }
  return $element;
}

function merci_merci_node_type_save($bundle_name) {
  if (merci_type_setting($bundle_name) == MERCI_RESOURCE) {
    merci_create_field(MERCI_ITEM_STATUS_FIELD, 'node', $bundle_name);
    merci_create_field(MERCI_ROLE_FIELD, 'node', $bundle_name);
  }
}

function merci_merci_fields_info() {
  // Exported field_base: 'field_merci_item_status'
  $fields[MERCI_ITEM_STATUS_FIELD] = array(
    'field' => array(
      'field_name' => MERCI_ITEM_STATUS_FIELD,
      'module' => 'list',
      'settings' => array(
        'allowed_values' => array(
          0 => 'Available',
          1 => 'Unavailable',
          2 => 'No Longer in Inventory',
        ),
      ),  
      'type' => 'list_text',
    ),
    'instance' => array(
      'default_value' => array(
        0 => array(
          'value' => 0,
        ),
      ),
      'description' => '',
      'label' => 'Merci Item Status',
      'required' => 1,
      'widget' => array(
        'active' => 1,
        'module' => 'options',
        'settings' => array(),
        'type' => 'options_select',
        'weight' => -3,
      ),
    ),
  );
  $fields[MERCI_ROLE_FIELD] = array(
    'field' => array(
      'cardinality' => -1,
      'field_name' => MERCI_ROLE_FIELD,
      'module' => 'rolereference',
      'type' => 'rolereference',
    ),
    'instance' => array(
      'label' => 'Merci Role Permission',
      'widget' => array(
        'active' => 1,
        'module' => 'options',
        'settings' => array(),
        'type' => 'options_buttons',
        'weight' => -2,
      ),
    ),
  );
  return $fields;
}
/**
 * Create an organic groups field in a bundle.
 *
 * @param $field_name
 *   The field name
 * @param $entity_type
 *   The entity type
 * @param $bundle
 *   The bundle name.
 */
function merci_create_field($field_name, $entity_type, $bundle) {
  if ($merci_field = merci_fields_info($field_name)) {
    $field = field_info_field($field_name);
    if (empty($field)) {
      $field = field_create_field($merci_field['field']);
    }

    $instance = field_info_instance($entity_type, $field_name, $bundle);
    if (empty($instance)) {
      $instance = $merci_field['instance'];
      $instance += array(
        'field_name' => $field_name,
        'bundle' => $bundle,
        'entity_type' => $entity_type,
      );

      field_create_instance($instance);
    }
  }
}

/**
 * Get all the modules fields that can be assigned to fieldable enteties.
 */
function merci_fields_info($field_name = NULL) {
  $return = &drupal_static(__FUNCTION__, array());

  if (empty($return)) {
    foreach (module_implements('merci_fields_info') as $module) {
      if ($fields = module_invoke($module, 'merci_fields_info')) {
        foreach ($fields as $key => $field) {
          // Add default values.
          $field += array(
            'entity type' => array(),
            'disable on node translate' => TRUE,
          );

          // Add the module information.
          $return[$key] = array_merge($field, array('module' => $module));
        }
      }
    }

    // Allow other modules to alter the field info.
    drupal_alter('merci_fields_info', $return);
  }

  return empty($field_name) ? $return : $return[$field_name];
}

/**
 * Implement hook_node_type_insert().
 */
function merci_node_type_insert($info) {
  merci_node_type_save($info->type);
}

/**
 * Implement hook_node_type_update().
 */
function merci_node_type_update($info) {
  merci_node_type_save($info->type);
}

/**
 * Add group and group content fields to new content types.
 *
 * @param $bundle_name
 *   The content type name.
 */
function merci_node_type_save($bundle_name) {
  module_invoke_all('merci_node_type_save', $bundle_name);
}

function merci_type_setting($type) {
  return variable_get('merci_type_setting_' . $type, 'disabled');
}
