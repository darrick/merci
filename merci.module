<?php

/**
 * @file
 * MERCI - Managed Equipment Reservation Checkout and Inventory
 */

// Item default availability options.
define('MERCI_AVA_F', 1);
define('MERCI_UNA_F', 2);
define('MERCI_AVA_T', 3);
define('MERCI_UNA_S', 4);

// Reservation status options.
define('MERCI_STATUS_UNCONFIRMED', 1);
define('MERCI_STATUS_PENDING', 2);
define('MERCI_STATUS_CHECKED_OUT', 3);
define('MERCI_STATUS_CHECKED_IN', 4);
define('MERCI_STATUS_CANCELLED', 5);
define('MERCI_STATUS_DENIED', 6);
define('MERCI_STATUS_NO_SHOW', 7);

// Bucket/resource status options.
define('MERCI_STATUS_ACTIVE', 1);
define('MERCI_STATUS_INACTIVE', 2);

// Bucket/resource sub-types.
define('MERCI_SUB_TYPE_ITEM', 1);
define('MERCI_SUB_TYPE_RESERVATION', 2);

// Item status for reservations.
define('MERCI_ITEM_STATUS_CANCELED', -2);
define('MERCI_ITEM_STATUS_CHECKED_IN', -1);
define('MERCI_ITEM_STATUS_AVAILABLE', 0);
define('MERCI_ITEM_STATUS_RESERVED', 1);
define('MERCI_ITEM_STATUS_CHECKED_OUT', 2);


module_load_include('inc', 'merci', 'includes/database');
module_load_include('inc', 'merci', 'includes/api');
/**
 * Implementation of hook_perm().
 */
function merci_perm() {
  return array('create reservations', 'create confirmed reservations', 'suspend MERCI access', 'administer MERCI', 'create reservations outside hours of operation', 'manage reservations', 'override max hours over closed days', 'view all reservations');
}

/**
 * Implementation of hook_menu().
 */
function merci_menu() {

  // Callback for AJAX adding of item selectors.
  $items['merci/js'] = array(
    'title' => 'Javascript Choice Form',
    'page callback' => 'merci_choice_js',
    'access arguments' => array('access content'),
    'file' => 'includes/menu.inc',
    'type' => MENU_CALLBACK,
  );

  $items['merci/taxonomy/%node/%/%'] = array(
    'title' => 'JSON interface for node taxonomy',
    'description' => 'Takes a node ID and returns taxonomy data as JSON',
    'page callback' => 'merci_taxonomy_json',
    'access arguments' => array('manage reservations'),
    'page arguments' => array(2, 3, 4),
    'file' => 'includes/menu.inc',
    'type' => MENU_CALLBACK,
  );


  // Adds Manage Equipment to Admin Interfaces
  //
  $items['admin/merci/manage'] = array(
    'title' => 'Manage Equipment',
    'description' => 'Manage Equipment Reservations, Checkout and Inventory (MERCI)',
    'position' => 'right',
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array('manage reservations'),
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
    'weight' => -19,
  );

  $items['admin/merci/manage/current_inventory'] = array(
    'title' => 'Current Inventory',
    'description' => 'Displays list',
    'page callback' => 'theme',
    'page arguments' => array('merci_current_inventory'),
    'access arguments' => array('manage MERCI'),
    'type' => MENU_NORMAL_ITEM,
  );

  // Standard Administration settings.
  $items['admin/settings/merci'] = array(
    'title' => 'MERCI Configuration',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('merci_admin_settings'),
    'access callback' => 'user_access',
    'access arguments' => array('administer MERCI'),
    'description' => 'Configure system settings for MERCI.',
    'file' => 'includes/merci.admin.inc',
  );

  $items['admin/settings/merci/edit'] = array(
    'title' => 'Edit',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  return $items;
}

/**
 * Implementation of hook_node_info().
 */
function merci_node_info() {
  return array(
    // Reservation nodes.
    'merci_reservation' => array(
      'name' => t('Reservation'),
      'module' => 'merci',
      'has_body' => FALSE,
      'description' => t("A reservation reserves a resource or group of resources for some period of time."),
    ),
  );
}

/**
 * Implementation of hook_node_type().
 */
function merci_node_type($op, $info) {

  switch ($op) {
    case 'update':

      if (isset($info->old_type) && $info->type != $info->old_type) {
        merci_node_type_update($info);
      }
      break;

    case 'delete':
      merci_node_type_delete($info->type);
      break;
  }
}

/**
 * Implementation of hook_access().
 */
function merci_access($op, $node, $account) {
  global $user;

  $type = isset($node->type) ? $node->type : $node;
  $uid = isset($node->uid) ? $node->uid : FALSE;

  if ($type == 'merci_reservation') {

    if (user_access('manage reservations')) {
      return TRUE;
    }
    elseif (user_access('view all reservations') && $op == 'view') {
      return TRUE;
    }
    elseif (user_access('create reservations') and !user_access('suspend MERCI access')) {
      //users working with their own reservations access reservation
      //additional check in merci_form permission to edit confirmed reservations
      // Users without administer or manage reservations permission can only alter their own Unconfirmed Reservations.
      if (($op == 'delete' or $op == 'update') && isset($node->merci_reservation_status)
         && $node->merci_reservation_status != MERCI_STATUS_UNCONFIRMED
         && !user_access('create confirmed reservations')) {
        return FALSE;
      }

      if ($uid === FALSE || $uid == $account->uid) {
        return TRUE;
      }
    }
    return FALSE;
  }
}
/**
 * Implementation of hook_load().
 */
function merci_load($node) {
  if ($node->type == 'merci_reservation') {
    $return = new stdClass();
    $return->merci_reservation_status = merci_reservation_status($node);

    // TODO get rid of merci array.  should match form api post fields.
    $return->merci_reservation_items = merci_reservation_items($node);

    return $return;
  }
}

function merci_validate_merci_selected_items($form, &$form_state) {
  $node = (object) $form_state['values'];

  $choices = $node->merci_reservation_items;

  $reservation_nid = $node->nid;

  // ****
  // Build date objects we'll need for our different validations.
  // ****
  $start              = $node->field_merci_date[0]['value'];
  $end                = $node->field_merci_date[0]['value2'];

  // Do this even for reservations with merci status of canceled and checked in.
  $choice_counts = array();
  $total_counts = array();
  $messages = array();
  foreach ($choices as $did => $item) {

    if (is_array($item)) {
      $value = $item['merci_item_nid'];
    }
    else {
      $value = $item;
    }

    if (is_numeric($did) and !$value) {
      $value = $item['type'];
    }

    if ($value) {
      // Only include active buckets, and content types the user
      // can reserve.
      $messages[$did] = '';
      if (is_numeric($value)) {
        $new_item = node_load($value);
        $title    = $new_item->title;
        $type     = $new_item->type;
      }
      else {
        $title = node_get_types('name', $value);
        $type = $value;
      }

      $content_settings = merci_load_item_settings($type);

      // Is this content type active?
      if ($content_settings->merci_active_status != MERCI_STATUS_ACTIVE) {
        $messages[$did] = '<div> ' . t("%name is not active.", array('%name' => $title)) . '</div>';
        continue;
      }

      // Does the user have access to manage reservations or this content type?
      if (!user_access('manage reservations') && !merci_check_content_type_user_permissions($type)) {
        $messages[$did] = '<div> ' . t("You do not have permission to reserve %name.", array('%name' => $title)) . '</div>';
        continue;
      }

      // Do we have the item available at this time?
      if (!isset($total_counts[$type])) {
        if (is_numeric($value)) {
          $item_options = merci_get_reservable_items($type, $start, $end, $reservation_nid);
          if (merci_type_setting($type) == 'bucket') {
            $total_counts[$type][$type] = $choice_counts[$type][$type] = merci_get_available_bucket_count($type, $start, $end, $node->vid) - $content_settings->merci_spare_items;
          }
          foreach ($item_options as $nid => $item_nid) {
            $total_counts[$type][$nid] = $choice_counts[$type][$nid] = 1;
          }
        }
        else {
          $total_counts[$type][$value] = $choice_counts[$type][$value] = merci_get_available_bucket_count($type, $start, $end, $node->vid) - $content_settings->merci_spare_items;
        }
      }
      if (!$choice_counts[$type][$value] and $total_counts[$type][$value]) {
        $messages[$did] = '<div> ' . t("You've selected too many %name's.  We only have %amount available at the times you've selected.", array('%name' => $title, '%amount' => $total_counts[$type][$value])) . '</div>';
      }
      elseif (!$choice_counts[$type][$value]) {
        $overdue_items_array = merci_overdue_items($type, $start, $reservation_nid = NULL);
        if (!empty($overdue_items_array)) {
          $messages[$did] = '<div> ' . t("%name is not available because it is still checked out by:", array('%name' => $title)) . '</div>';
          foreach ($overdue_items_array as $reservations) {
            foreach (array_keys($reservations) as $nid) {
              $overdue = node_load($nid);
              $messages[$did] .= '<div> ' . l($overdue->title, 'node/' . $overdue->nid) . '</div>';
            }
          }
        }
        else {
          //TODO: should not be doing theming here.
          $messages[$did] .= theme('merci_conflict_grid', $type, $title, $start, $end, $value, $node->vid);
        }
      }
      else {
        //drupal_set_message(t('There are no time conflicts with this Reservation.'));
      }
      $choice_counts[$type][$value]--;
      if (is_numeric($value) ) {
        $choice_counts[$type][$type]--;
      }

      // Check item restrictions.  max hours, etc.
      $restrictions = merci_check_content_type_restrictions($type, $start, $end);

      if (!empty($restrictions)) {
        foreach ($restrictions as $restriction) {
          $messages[$did] .= '<div>' . t($restriction, array('%name' => $title)) . '</div>';
        }
      }
      if (!empty($messages[$did])) {
        form_set_error("merci_reservation_items][$did][merci_item_nid", $messages[$did]);
      }
    }
  }
  return $messages;
}

// Loads the current settings for reservable item nodes.
/* If you just want the content type settings just pass only node->type.
 */

function merci_load_item_settings($object) {

  if (is_string($object)) {
    $type = $object;
  }
  else {
    $node = (array) $object;
    $type = $node['type'];
  }

  $item_settings = array();
  // Settings from the content type edit page.
  $content_settings = merci_content_types($type);
  if (empty($content_settings)) {
    $content_settings = array();
  }

  if ($node['nid']) {
    // Settings common to all merci item nodes.
    // resource or bucket.
    $merci_type = $content_settings['merci_type_setting'];

    $item_settings = db_fetch_array(db_query("SELECT merci_default_availability, merci_sub_type, merci_item_status FROM {merci_reservation_item_node} WHERE vid = %d", $node['vid']));
    switch ($merci_type) {
      case 'bucket':
        // TODO: move to seperate module.
        if ($item_settings['merci_sub_type'] == MERCI_SUB_TYPE_RESERVATION) {
          unset($item_settings['merci_default_availability']);
          unset($item_settings['merci_item_status']);
          $item_settings += db_fetch_array(db_query("SELECT merci_late_fee_per_hour, merci_rate_per_hour, merci_fee_free_hours FROM {merci_bucket_node} WHERE vid = %d", $node['vid']));
        }
        break;

      case 'resource':
        // TODO: move to seperate module.
        $item_settings += db_fetch_array(db_query("SELECT merci_late_fee_per_hour, merci_rate_per_hour, merci_fee_free_hours, merci_min_cancel_hours, merci_autocheckout, merci_autocheckin, merci_selfcheckout FROM {merci_resource_node} WHERE vid = %d", $node['vid']));
        break;
    }
  }

  if ($item_settings) {
    return (object) ($item_settings + $content_settings);
  }
  else {
    return (object) ($content_settings);
  }
}

/**
 * Implementation of hook_nodeapi().
 */
function merci_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {

  // Process active MERCI node types and reservation nodes.
  if (merci_is_merci_type($node->type) || $node->type == 'merci_reservation') {
    // reservation, bucket or resource.
    $type = $node->type == 'merci_reservation' ? 'reservation' : merci_type_setting($node->type);
    switch ($op) {
      //case 'prepare': prepare and load are always called one after the other.  Just need to use one.
      case 'load':
        // Merge in reservable items settings or else just use the default defined in the content type.
        if ($type != 'reservation') {
          return (array) (merci_load_item_settings($node));
        }
        break;

      case 'validate':
        if ($type != 'reservation') {
          merci_validate_default_availability($node);
        }
        break;

      case 'insert':
      case 'update':
        if ($type != 'reservation') {
          if ($op == 'insert' || $node->revision) {
            drupal_write_record('merci_' . $type . '_node', $node);
            drupal_write_record('merci_reservation_item_node', $node);
          }
          else {
            drupal_write_record('merci_' . $type . '_node', $node, 'vid');
            drupal_write_record('merci_reservation_item_node', $node, 'vid');
          }
        }
        break;

      case 'delete':
        // In the case were a reservation placeholder node is being
        // deleted, remove it from the detail table here.
        if ($type != 'reservation') {
          $node->merci_placeholder_nid = $node->nid;
          merci_delete_record('merci_reservation_detail', $node, 'merci_placeholder_nid');
          merci_delete_record('merci_' . $type . '_node', $node, 'nid');
          merci_delete_record('merci_reservation_item_node', $node, 'nid');
        }
        break;

      case 'delete revision':
        if ($type != 'reservation') {
          merci_delete_record('merci_' . $type . '_node', $node, 'vid');
          merci_delete_record('merci_reservation_item_node', $node, 'vid');
        }
        else {
          merci_delete_record('merci_reservation', $node, 'vid');
          merci_delete_record('merci_reservation_detail', $node, 'vid');
        }
        break;
    }
  }
}

/**
 * Implementation of hook_theme().
 */
function merci_theme() {
  return array(
    'merci_choices' => array(
      'arguments' => array('form' => NULL),
      'file' => 'theme.inc',
    ),
    'merci_build_reservation_table_form' => array(
      'arguments' => array('form' => NULL),
      'file' => 'theme/theme.inc',
    ),
    'merci_conflict_grid' => array(
      'template' => 'merci_conflict_grid',
      'arguments' => array('type' => NULL, 'title' => NULL, 'start' => NULL, 'end' => NULL, 'nid' => NULL, 'reservation_vid' => NULL),
      'path' => drupal_get_path('module', 'merci') . '/theme',
      'file' => 'theme.inc',
    ),
    'merci_reservation_table' => array(
      'template' => 'merci_reservation_table',
      'path' => drupal_get_path('module', 'merci') . '/theme',
      'arguments' => array(
        'reservations' => NULL,
        'count' => NULL,
        'hours' => NULL,
        'title' => NULL,
      ),
    ),
    'merci_current_inventory' => array(
      'path' => drupal_get_path('module', 'merci') . '/theme',
      'file' => 'theme.inc',
    ),
    'merci_type_setting' => array(
      'path' => drupal_get_path('module', 'merci') . '/theme',
      'arguments' => array('form' => NULL),
      'file' => 'theme.inc',
    ),
  );
}

/**
 * Implementation of hook_cron().
 */
function merci_cron() {

  // 2009-05-22 20:45:00
  $time = gmdate('Y-m-j H:i:s');

  // Determine CCK table and columns the date data is stored in.
  $field             = content_fields('field_merci_date');
  $db_info           = content_database_info($field);
  $table             = $db_info['table'];
  $column_start_date = $db_info['columns']['value']['column'];
  $column_end_date   = $db_info['columns']['value2']['column'];

  $args = array($time, $time, MERCI_STATUS_UNCONFIRMED, MERCI_STATUS_PENDING);
  // Select reservation nodes where all reserved items and resources are autocheckout.
  $reservations = db_query("SELECT n.nid FROM {node} AS n
        INNER JOIN {" . $table . "} ct ON ct.vid = n.vid
        INNER JOIN {merci_reservation} AS mr ON n.vid = mr.vid
          WHERE $column_start_date <= '%s' AND $column_end_date > '%s'
            AND mr.merci_reservation_status IN (%d, %d)", $args);

  while ($reservation_nid = db_result($reservations)) {

    $reservation = node_load($reservation_nid);

    //check child items of that reservations for autocheckout
    foreach ($reservaton->merci_reservation_items as $item) {
      $node = node_load($item['merci_item_nid']);
      if (!$node or !$node->merci_autocheckout) {
        // skip out to the next reservation.
        continue 2;
      }
    }

    //after checking all of the autocheckout settings for all the child items, are they all autocheckout?
    watchdog('merci', "Setting node " . $reservation_nid . " to checked out");
    $node->merci_reservation_status = MERCI_STATUS_CHECKED_OUT;
    node_save($node);
  }


  $args = array($time, MERCI_STATUS_CHECKED_OUT);
  // Select reservation nodes where all reserved items and resources are autocheckin.
  $reservations = db_query("SELECT n.nid FROM {node} AS n
        INNER JOIN {" . $table . "} ct ON ct.vid = n.vid
        INNER JOIN {merci_reservation} AS mr ON n.vid = mr.vid
          WHERE $column_end_date <= '%s'
            AND mr.merci_reservation_status IN (%d)", $args);

  while ($reservation_nid = db_result($reservations)) {

    //check child items of that reservations for autocheckin
    $reservation = node_load($reservation_nid);

    foreach ($reservaton->merci_reservation_items as $item) {
      $node = node_load($item['merci_item_nid']);
      if (!$node or !$node->merci_autocheckin) {
        // skip out to the next reservation.
        continue 2;
      }
    }

    //after checking all of the autocheckout settings for all the child items, are they all autocheckout?
    watchdog('merci', "Setting node " . $reservation_nid . " to checked in");
    $node->merci_reservation_status = MERCI_STATUS_CHECKED_IN;
    node_save($node);
  }

  // Give no shows a one hour grace period.
  // TODO: move grace period to admin option.
  // 2009-05-22 20:45:00
  $time = gmdate('Y-m-j H:i:s', time() + 3600);
  //find all pending reservations that have started and set their stauts to no show
  $args = array($time, MERCI_STATUS_PENDING);
  // Select reservation nodes where all reserved items and resources are autocheckin.
  $reservations = db_query("SELECT n.nid FROM {node} AS n
        INNER JOIN {" . $table . "} ct ON ct.vid = n.vid
        INNER JOIN { merci_reservation } AS mr ON n.vid = mr.vid
          WHERE $column_start_date <= '%s'
            AND mr.merci_reservation_status IN (%d)
          ", $args);

  while ($nid = db_result($reservations)) {
    watchdog('merci', "Setting node " . $nid . " to no show");
    $node = node_load($nid);
    $node->merci_reservation_status = MERCI_STATUS_NO_SHOW;
    node_save($node);
  }
}

/**
 * Implementation of hook_simpletest().
 */
function merci_simpletest() {
  $dir = drupal_get_path('module', 'merci') . '/tests';
  $tests = file_scan_directory($dir, '\.test$');
  return array_keys($tests);
}

/**
 * Builds an individual item selector.
 *
 * @param $node
 *   The reservation node object.
 * @param $form_state
 *   Current form state array.
 * @param $delta
 *   Which selector number to build.
 * @param $default
 *   Default value for the select.
 *
 * @return
 *   The form array for the selector.
 */
function _merci_choice_form($node, $form_state, $delta, $default = '', $reset = NULL) {

  static $options = array();

  // We'll manually set the #parents property of these fields so that
  // their values appear in the $form_state['values']['choice'] array.
  //$buckets = t('Buckets');
  if (empty($options) or $reset) {
    // NOTE: we don't filter by node here because we only want items not
    //reserved by any node including the node calling the function.
    $options = merci_build_reservable_items($node, $form_state, NULL);

    // Group the buckets.
    $vid = variable_get('merci_equipment_grouping_vid', 0);

    $sorted = array();
    foreach ($options['options'] as $grouping => $items) {
      if (!is_array($items)) {
        continue;
      }
      foreach ($items as $id => $name) {
        if (is_numeric($id)) {
          // Resource
          $type = db_result(db_query('SELECT type FROM {node} WHERE nid = %d', $id));
        }
        else {
          $type = $id;
        }

        $tid = variable_get('merci_grouping_' . $type, 0);

        if ($tid) {
          $term = taxonomy_get_term($tid);
          if ($term) {
            $sorted[$term->name][$id] = $name;
            unset($options['options'][$grouping][$id]);
          }
        }
      }
      if (empty($options['options'][$grouping])) {
        unset($options['options'][$grouping]);
      }
    }
    // Order them.
    $terms = taxonomy_get_tree($vid);
    foreach ($terms as $term) {
      if (isset($sorted[$term->name])) {
        $options['options'][$term->name] = $sorted[$term->name];
      }
    }
  }

  $form = array(
    '#type' => 'select',
    '#options' => $options['options'],
    '#default_value' => $default,
    //'#parents' => array('choice', $delta, 'item'),
  );

  return $form;
}


function _merci_content_type_info($reset = FALSE) {
  static $info;
  if ($reset || !isset($info)) {
    if (!$reset && $cached = cache_get('merci_content_type_info')) {
      $info = $cached->data;
    }
    else {
      $info = array();
      // Load MERCI node type settings.
      $merci_settings = db_query("SELECT * FROM {merci_node_type} mt INNER JOIN {node_type} nt ON mt.type = nt.type WHERE merci_type_setting <> 'disabled'");
      // with the correct stuff..
      while ($merci_setting = db_fetch_array($merci_settings)) {
        $merci_setting['type_name'] = $merci_setting['name'];
        unset($merci_setting['name']);
        $info[$merci_setting['type']] = $merci_setting;
      }
      cache_set('merci_content_type_info', $info);
    }
  }
  return $info;
}

/**
 * Validates the state change of a reservable item.
 *
 * @param $node
 *   The item node.
 */
function merci_validate_default_availability($node) {

  // Only perform the check if the item is set to an unavailable state.
  if (in_array((int) $node->merci_default_availability, array(MERCI_UNA_F, MERCI_UNA_S))) {
    // Determine CCK table and columns the date data is stored in.
    $field           = content_fields('field_merci_date');
    $db_info         = content_database_info($field);
    $table           = $db_info['table'];
    $column_end_date = $db_info['columns']['value2']['column'];

    $time = gmdate('Y-m-d H:i:s');

    // Pull any incomplete reservations that use the item in question
    $reservations = db_query(db_rewrite_sql("SELECT n.nid, n.title FROM {node} n INNER JOIN {" . $table . "} ct ON ct.vid = n.vid INNER JOIN {merci_reservation_detail} md ON ct.vid = md.vid WHERE md.merci_item_nid = %d AND " . $column_end_date . " >= '%s' AND NOT (md.merci_item_status <= %d)"), $node->nid, $time, MERCI_ITEM_STATUS_AVAILABLE);

    $bad_reservations = array();
    while ($reservation = db_fetch_object($reservations)) {
      $bad_reservations[] = l($reservation->title, "node/$reservation->nid/edit", array('query' => drupal_get_destination()));
    }

    if (!empty($bad_reservations)) {
      form_set_error('merci_default_availability', t('%title can not be set to an unavailable status until it is removed from the following reservations:', array('%title' => $node->title)) . theme('item_list', $bad_reservations));
    }
  }
}

/**
 * Validates if an item node can be deleted.
 *
 * @param $node
 *   The item node.
 * @param $single
 *   TRUE if a single item node deletion is being processed, FALSE otherwise.
 *
 * @return
 *   TRUE if the item can be deleted, FALSE otherwise.
 */
function merci_delete_item_validate($node) {
  // Only validate bucket/resource items.
  if ($node->type != 'merci_reservation' && $node->merci_type_setting != 'disabled' && $node->merci_sub_type == MERCI_SUB_TYPE_ITEM) {
    // Determine CCK table and columns the date data is stored in.
    $field   = content_fields('field_merci_date');
    $db_info = content_database_info($field);
    $table   = $db_info['table'];

    // Join on nid here so that any version of the reservation that contain
    // the item is caught.
    // Pull any reservations that use the item in question
    $reservations = db_query("SELECT n.nid, n.title FROM {node} n INNER JOIN {" . $table . "} ct ON ct.vid = n.vid INNER JOIN {merci_reservation_detail} md ON ct.vid = md.vid WHERE md.merci_item_nid = %d", $node->nid);

    $bad_reservations = array();
    while ($reservation = db_fetch_object($reservations)) {
      // Key by nid to prevent duplicate revisions from appearing.
      $bad_reservations[$reservation->nid] = l($reservation->title, "node/$reservation->nid/edit", array('query' => drupal_get_destination()));
    }

    if (!empty($bad_reservations)) {
      drupal_set_message(t('%title can not be deleted, because it is associated with the following reservations:', array('%title' => $node->title)) . theme('item_list', $bad_reservations), 'error');
      // Lock out single deletion attempts here.
      return FALSE;
    }
  }

  return TRUE;
}

/**
 * Validates saving of MERCI node types.
 */
function merci_node_type_save_validate($form, &$form_state) {
  $values = $form_state['values'];
  // Only validate node types set to an inactive status.
  if ($values['merci_type_setting'] != 'disabled' && (int) $values['merci_active_status'] == MERCI_STATUS_INACTIVE) {
    // Determine CCK table and columns the date data is stored in.
    $field           = content_fields('field_merci_date');
    $db_info         = content_database_info($field);
    $table           = $db_info['table'];
    $column_end_date = $db_info['columns']['value2']['column'];

    $time = gmdate('Y-m-d H:i:s');
    $type_setting = $values['merci_type_setting'];

    // Pull all active reservations that use the node type.
    $reservations = db_query("SELECT ctn.nid, ctn.title FROM {" . $table . "} ct INNER JOIN {merci_reservation_detail} md ON ct.vid = md.vid INNER JOIN {node} ctn ON ct.vid = ctn.vid INNER JOIN {merci_{$type_setting}_node} m ON md.merci_placeholder_nid = m.nid INNER JOIN {node} mn ON m.vid = mn.vid  WHERE mn.type = '%s' AND m.merci_sub_type = %d AND $column_end_date >= '%s' AND NOT (md.merci_item_status <= %d)", $values['old_type'], MERCI_SUB_TYPE_RESERVATION, $time, MERCI_ITEM_STATUS_CHECKED_IN);

    $bad_reservations = array();
    while ($reservation = db_fetch_object($reservations)) {
      $bad_reservations[] = l($reservation->title, "node/$reservation->nid/edit", array('query' => drupal_get_destination()));
    }

    if (!empty($bad_reservations)) {
      form_set_error('merci_active_status', t('@type_setting can not be set to an inactive status until all @type_setting items are removed from the following reservations:', array('@type_setting' => $type_setting)) . theme('item_list', $bad_reservations));
    }
  }
}

/**
 * Validates deletion of node types.
 *
 * @param $type
 *   The type being deleted.
 */
function merci_delete_node_type_validate(&$form) {

  $type = $form['type']['#value'];
  // Only validate active MERCI node types.
  if (merci_is_merci_type($type)) {
    //$settings = merci_load_item_settings($type);
    $merci_type_setting = merci_type_setting($type);

    // Determine CCK table and columns the date data is stored in.
    $field   = content_fields('field_merci_date');
    $db_info = content_database_info($field);
    $table   = $db_info['table'];

    // Join on nid here so that any version of the reservation that contain
    // the bucket/resource is caught.
    $reservations = db_query("SELECT ctn.nid, ctn.title FROM {" . $table . "} ct INNER JOIN {merci_reservation_detail} md ON ct.vid = md.vid INNER JOIN {node} ctn ON ct.nid = ctn.nid INNER JOIN {merci_{$merci_type_setting}_node} m ON md.merci_placeholder_nid = m.nid INNER JOIN {node} mn ON m.vid = mn.vid  WHERE mn.type = '%s' AND m.merci_sub_type = %d ORDER BY ct.nid, ct.vid", $type, MERCI_SUB_TYPE_RESERVATION);

    $bad_reservations = array();
    while ($reservation = db_fetch_object($reservations)) {
      $bad_reservations[$reservation->nid] = l($reservation->title, "node/$reservation->nid/edit", array('query' => drupal_get_destination()));
    }

    if (!empty($bad_reservations)) {
      $name = node_get_types('name', $type);
      drupal_set_message(t('@type can not be deleted because it is associated with the following reservations:', array('@type' => $name)) . theme('item_list', $bad_reservations), 'error');
      unset($form['actions']['submit']);
    }
  }
}

/**
 * Adds items to reservation on creation/update.
 *
 * @param $node
 *   The reservation node.
 */
function merci_add_reservation_items($node) {

  $member_total = 0;
  $commercial_total = 0;

  $hours = round(strtotime($node->field_merci_date[0]['value2']) - strtotime($node->field_merci_date[0]['value'])) / 3600;

  $exempt_items = array();
  // Update existing items or add new ones.
  if (isset($node->merci_reservation_items)) {
    foreach ($node->merci_reservation_items as $did => $item) {

      if (empty($item['merci_item_nid']) and !$item['type']) {
        continue;
      }

      // If we are copying a reservation.  I.e. via node_repeat
      if ($item['merci_placeholder_nid'] and $node->is_new) {
        $placeholder_node = node_load($item['merci_placeholder_nid']);
        $placeholder_node->nid = NULL;
        $placeholder_node->vid = NULL;
        $placeholder_node = node_submit($placeholder_node);
        node_save($placeholder_node);
        $item['merci_placeholder_nid'] = $placeholder_node->nid;
      }
      // Create a placeholder node if we don't have one yet.
      if (!$item['merci_placeholder_nid']) {
        // Resource.
        if (is_numeric($item['merci_item_nid'])) {
          $item_node        = node_load($item['merci_item_nid']);
          $item['type']        = $item_node->type;
          $item['item_title']       = $item_node->title;
          $settings = $item_node;
        }
        // Bucket.
        elseif ($item['merci_item_nid']) {

          $item['type']        = $item['merci_item_nid'];
          $item['name']  = node_get_types('name', $item['type']);
          $settings = merci_load_item_settings($item['type']);
          if ($settings->merci_auto_assign_bucket_item) {
            $date_info = $node->field_merci_date[0];
            $start     = $date_info['value'];
            $end       = $date_info['value2'];

            $item['merci_item_nid'] = merci_get_suggested_bucket_item($item['type'], $start, $end, $exempt_items);
            $exempt_items[] = $item['merci_item_nid'];
            $item_node        = node_load($item['merci_item_nid']);
            $item['item_title'] = $item_node->title;
            $settings = $item_node;
          }
        }
        else {
          break;
        }
        $title = $item['item_title'] ? $item['item_title']   : $item['name'];

        // Build the item's placeholder node.
        $reservation = new stdClass();
        $reservation->type = $item['type'];
        $reservation->name = $node->name;
        $reservation->uid = $node->uid;
        $reservation->title = "$title " . t('(Reservation)');
        $reservation->body = '';
        $reservation->status = 0;
        $reservation->promote = 0;
        $reservation->sticky = 0;

        // MERCI specific data.
        $reservation->merci_default_availability = MERCI_AVA_F;
        $reservation->merci_sub_type = MERCI_SUB_TYPE_RESERVATION;

        // Use the item specific accounting data if an item is assigned,
        // otherwise fall back to the content type defaults.
        // TODO move to nodeapi insert and update ops.
        //Add to commerical rate
        //print '<pre>';
        //print_r();
        $rate = $settings->merci_rate_per_hour;
        $commercial_total = $commercial_total + ($hours * $rate);
        $reservation->merci_late_fee_per_hour = $settings->merci_late_fee_per_hour;
        $reservation->merci_rate_per_hour = $settings->rate_per_hour;
        $reservation->merci_fee_free_hours = $settings->fee_free_hours;
        $reservation = node_submit($reservation);
        node_save($reservation);

        $item['merci_placeholder_nid'] = $reservation->nid;
      }

      // Update the state of all items with associations.
      switch ((int) $node->merci_reservation_status) {
        case MERCI_STATUS_UNCONFIRMED:
        case MERCI_STATUS_PENDING:
          $item_status = MERCI_ITEM_STATUS_RESERVED;
          break;

        case MERCI_STATUS_CHECKED_OUT:
          $item_status = MERCI_ITEM_STATUS_CHECKED_OUT;
          break;

        case MERCI_STATUS_CHECKED_IN:
          $item_status = MERCI_ITEM_STATUS_CHECKED_IN;
          break;

        case MERCI_STATUS_CANCELLED:
          $item_status = MERCI_ITEM_STATUS_CANCELED;
          break;
        case MERCI_STATUS_DENIED:
          $item_status = MERCI_ITEM_STATUS_AVAILABLE;
          break;
      }

      // If we have an item assigned.  Set status to reserved.
      $item['merci_item_status'] = $item_status;

      if ($node->revision or is_string($did) or $node->is_new) {
        $item['nid'] = $node->nid;
        $item['vid'] = $node->vid;
        drupal_write_record('merci_reservation_detail', $item);
      }
      else {
        $item['did'] = $did;
        drupal_write_record('merci_reservation_detail', $item, 'did');
      }

      $item_status = $item_status == MERCI_ITEM_STATUS_CHECKED_OUT ? MERCI_ITEM_STATUS_CHECKED_OUT : MERCI_ITEM_STATUS_AVAILABLE;
      if (is_numeric($item['merci_item_nid']) and $item['merci_item_nid'] > 0) {
        $update = array();
        $update['nid'] = $item['merci_item_nid'];
        $update['merci_item_status'] = $item_status;
        drupal_write_record('merci_reservation_item_node', $update, 'nid');
      }
    }
  }
}

/**
 * Builds the form item for the status display.
 *
 * @param $form_state
 *   Current form state.
 * @param $status
 *   Current status
 *
 * @return
 *   The form array.
 */
function merci_display_reservation_status(&$form_state, $status) {
  $form['merci_reservation_status'] = array(
    '#type' => 'item',
    '#title' => t('Status'),
    '#value' => $status,
  );

  return $form;
}

/**
 * Builds the table of existing reserved items.
 *
 * @param $form_state
 *   Current form state.
 * @param $node
 *   The reservation node.
 * @param $edit_page
 *   TRUE if the table is on the edit page for the reservation, FALSE otherwise.
 *
 * @return
 *   The form array.
 */
function merci_build_reservation_table_form(&$form_state, $node, $edit_page = FALSE) {
  global $user;

  $table            = array();
  $table['#theme']  = 'merci_build_reservation_table_form';
  $table['#node']   = $node;
  $table['#tree']   = TRUE;
  $table['#table']  = array();
  $table['#header'] = array(
    t('Item'),
  );

  $reservation_items = array();
  $items = $node->merci_reservation_items;

  if (!$items) {
    return $table;
  }

  $table['#header'][] = t('Type');
  foreach ($items as $did => $item) {

    if (!is_numeric($did)) {
      continue;
    }
    $form = array();

    foreach ($item as $key => $value) {
      $form[$key] = array(
        '#type' => 'value',
        '#value' => $value,
      );
    }

    $form['display_name']['#value'] = $form['name']['#value'];
    $form['display_item_title']['#value'] = $form['item_title']['#value'];

    if (user_access("manage reservations")) {
      if (merci_has_accessories($item['type'])) {
        $placeholder_node = node_load($item['merci_placeholder_nid']);

        if (!in_array(t('Accessories'), $table['#header'])) {
          $table['#header'][] = t('Accessories');
        }

        if ($edit_page) {
          if ($node->merci_reservation_status == MERCI_STATUS_CHECKED_OUT) {
            $collapsed = FALSE;
          }
          else {
            $collapsed = TRUE;
          }

          // Container for just the item selector.
          $form['accessories'] = array(
            '#type' => 'fieldset',
            '#title' => t('Add accessories'),
            '#collapsible' => TRUE,
            '#collapsed' => $collapsed,
            '#prefix' => '<div id="merci-accessories-' . $placeholder_node->nid . '">',
            '#suffix' => '</div>',
            'choices' => merci_build_accessory_form($form_state, $placeholder_node, $did),
          );
        }
        else {
          $accessories = '';
          $terms = taxonomy_node_get_terms($placeholder_node);

          if (!empty($terms)) {
            foreach ($terms as $accessory) {
              $accessories .= $accessory->name . ', ';
            }
          }
          $form['accessories'] = array(
            '#type' => 'markup',
            '#title' => t('Accessories'),
            '#value' => $accessories,
          );

        }

        //$operations .= ' &nbsp;&nbsp;' . l(t('edit'), "node/$item->merci_placeholder_nid/edit", array('query' => drupal_get_destination()));
        // Only allow editing or deletion if unconfirmed or confirmed.
        if ($edit_page && $node->merci_reservation_status >= MERCI_STATUS_CHECKED_OUT) {
          foreach ($form['accessories']['choices'] as $vid => $values) {
            $form['accessories']['choices'][$vid]['#disabled'] = TRUE;
          }
          $form['accessories']['#title'] = t('Accessories');
        }
      }
    }
    // Only allow editing or deletion if unconfirmed or confirmed.
    if ($edit_page && $node->merci_reservation_status < MERCI_STATUS_CHECKED_OUT) {
      if (!in_array(t('Operations'), $table['#header'])) {
        $table['#header'][] = t('Operations');
      }
      //@TODO: Should users be able to remove items from confirmed reservations?
      if (user_access("manage reservations") || $node->uid == $user->uid) {
        if (!in_array(t('Operations'), $table['#header'])) {
          $table['#header'][] = t('Operations');
        }
        $operations = ' &nbsp;&nbsp;' . l(t('delete'), "node/" . $item['merci_placeholder_nid'] . "/delete", array('query' => drupal_get_destination()));
      }
      $operations .= ' &nbsp;&nbsp;' . l(t('edit'), "node/" . $item['merci_placeholder_nid'] . "/edit", array('query' => drupal_get_destination()));
    }
    $form['ops']['#value'] = $operations;

    $type_setting = merci_type_setting($item['type']);

    if ($edit_page && $type_setting == 'bucket') {
      // Only users with manage reservations permission can change the bucket item assignment.
      if (user_access('manage reservations')) {

        $options = array(0 => t('<Select>'));
        $options += merci_get_available_bucket_items($node, $item['type']);
        $form['merci_item_nid'] = array(
          '#type' => 'select',
          '#options' => $options,
          '#default_value' => $item['merci_item_nid'],
        );
        if ($node->merci_reservation_status >= MERCI_STATUS_CHECKED_OUT) {
          $form['merci_item_nid']['#disabled'] = true;
        }
      }
    }

    //$form['#table'][$did]['accessories'] = $accessories;
    $table[$did] = $form;
  }

  return $table;
}

/**
 * Pulls an array of items that are reservable for the content type and date range.
 *
 * @param $content_type
 *   The content type name of the bucket/resource.
 * @param $start
 *   Start time in DATETIME format UTC timezone.
 * @param $end
 *   End time in DATETIME format UTC timezone.
 * @param $reservation_nid
 *   (Optional) A reservation nid to exclude from the reserved items.
 *
 * @return
 *   An array of reservable items, in select option format.
 */
function merci_get_reservable_items($content_type, $start = NULL, $end = NULL, $reservation_nid = NULL, $overdue = TRUE) {


  $merci_type = merci_type_setting($content_type);
  // Pull reservable items.  This query takes the following into consideration:
  //   1. Pulls all all item nodes of the content type that are in an available or checked in state,
  //   2. Excludes all item nodes that have associated reservations in the date range
  //      of the this reservation where the item is in an already reserved or checked out state.
  //   3. Allows a reservation to be excluded from the exclusions if necessary (this
  //      is usually used to allow an already assigned item to not conflict with itself.
  //   4. Exclude items from past reservations where the item is in a checked out state.

  $query = "SELECT n.nid, n.title FROM {node} n
    INNER JOIN {merci_reservation_item_node} m ON n.vid = m.vid
      WHERE m.merci_default_availability IN (%d, %d)
        AND n.type = '%s'
        AND m.merci_sub_type = %d
        ";

  $args = array(MERCI_AVA_F, MERCI_AVA_T, $content_type, MERCI_SUB_TYPE_ITEM);


  if ($start) {
    // Determine CCK table and columns the date data is stored in.
    $field             = content_fields('field_merci_date');
    $db_info           = content_database_info($field);
    $table             = $db_info['table'];
    $column_start_date = $db_info['columns']['value']['column'];
    $column_end_date   = $db_info['columns']['value2']['column'];

    $args = array_merge($args, array($start, $end, $start, $end, $start, $end, MERCI_ITEM_STATUS_AVAILABLE));

    // If there's an already selected bucket item, then we need to make sure we
    // include it in the list of available items.
    $query .= "
      AND n.nid NOT IN
      (SELECT md2.merci_item_nid FROM {" . $table . "} ct
      INNER JOIN {merci_reservation_detail} md2 ON ct.vid = md2.vid
      INNER JOIN {merci_reservation_item_node} m2 ON md2.merci_item_nid = m2.nid
      INNER JOIN {node} ctn ON ctn.vid = ct.vid
      INNER JOIN {node} m2n ON m2.vid = m2n.vid
      WHERE (
        (
          (($column_start_date >= '%s' AND $column_start_date <= '%s')
          OR ($column_end_date >= '%s' AND $column_end_date <= '%s')
          OR ($column_start_date <= '%s' AND $column_end_date >= '%s'))
          AND NOT md2.merci_item_status <= %d
        ) ";
    if ($reservation_nid) {
      $where = ' AND md2.nid <> %d';
      $args[] = $reservation_nid;
    }

    $query .= "
      )
      $where
    )
    ";

  }
  $query .= " ORDER BY n.title";

  $items = db_query($query, $args);
  $options = array();

  while ($item = db_fetch_object($items)) {
    $options[$item->nid] = $item->title;
  }

  if ($overdue) {
    $overdue_items_array = merci_overdue_items($content_type, $start, $reservation_nid);
    if (!empty($overdue_items_array)) {
      foreach ($options as $item_nid => $title) {
        if (array_key_exists($item_nid, $overdue_items_array)) {
          unset($options[$item_nid]);
        }
      }
    }
  }
  return $options;
}

function merci_overdue_items($content_type, $start, $reservation_nid = NULL) {
  // Determine CCK table and columns the date data is stored in.
  $field             = content_fields('field_merci_date');
  $db_info           = content_database_info($field);
  $table             = $db_info['table'];
  $column_start_date = $db_info['columns']['value']['column'];
  $column_end_date   = $db_info['columns']['value2']['column'];

  // pull reservations in the past which are still checked out.
  $start = date_create($start, timezone_open("UTC")) >= date_create("now") ? gmdate("Y-m-d H:i:s") : $start;
  $args = array($start, $content_type, MERCI_ITEM_STATUS_CHECKED_OUT);

  $merci_type = merci_type_setting($content_type);

  // If we're checking an existing reservation, exclude it from the
  // reserved items.
  if (isset($reservation_nid)) {
    $where = ' AND ct.nid <> %d';
    $args[] = $reservation_nid;
  }

  $reserved_nodes = db_query("
    SELECT ct.nid,$column_start_date AS field_merci_date_value, $column_end_date AS field_merci_date_value2 ,md.merci_item_nid FROM {" . $table . "} ct
    INNER JOIN {merci_reservation_detail} md on ct.vid = md.vid
    INNER JOIN {merci_{$merci_type}_node} m on md.merci_placeholder_nid = m.nid
    INNER JOIN {node} ctn on ct.vid = ctn.vid
    INNER JOIN {node} mn on m.vid = mn.vid
    WHERE ($column_end_date <= '%s')
    AND mn.type = '%s'
    AND md.merci_item_nid !=0
    AND md.merci_item_status = %d
    $where",
    $args
  );

  // Use up items for assigned nodes.
  while ($node = db_fetch_object($reserved_nodes)) {
    $total_items_array[$node->merci_item_nid][$node->nid] = $node;
  }

  return $total_items_array;
}

function _merci_sort_array($a, $b) {
  return count($b) - count($a);
}
//TODO: the following three functions look very much a like.
function merci_reserved_bucket_items($content_type, $start = NULL, $end = NULL, $reservation_vid = NULL, $overdue = TRUE) {

  // Determine CCK table and columns the date data is stored in.
  $field             = content_fields('field_merci_date');
  $db_info           = content_database_info($field);
  $table             = $db_info['table'];
  $column_start_date = $db_info['columns']['value']['column'];
  $column_end_date   = $db_info['columns']['value2']['column'];

  // Get all assignable nodes for this bucket item.
  $total_items_nodes = db_query("SELECT n.nid FROM {node} n INNER JOIN {merci_reservation_item_node} m ON n.vid = m.vid WHERE n.type = '%s' AND m.merci_sub_type = %d AND m.merci_default_availability IN (%d, %d)", $content_type, MERCI_SUB_TYPE_ITEM, MERCI_AVA_F, MERCI_AVA_S);
  $total_items_array = array();
  while ($ctnodes = db_fetch_array($total_items_nodes)) {
    $total_items_array[$ctnodes['nid']] = array();
  }

  $args = array($start, $end, $start, $end, $start, $end, $content_type, MERCI_ITEM_STATUS_AVAILABLE);

  // If we're checking an existing reservation, exclude it from the
  // reserved items.
  if (isset($reservation_vid)) {
    $where = ' AND ct.vid <> %d';
    $args[] = $reservation_vid;
  }
  else {
    $where = '';
  }

  // pull reservations with assigned nodes and status of MERCI_ITEM_STATUS_RESERVED or MERCI_ITEM_STATUS_CHECKED_OUT
  $reserved_nodes = db_query("
    SELECT ct.nid,$column_start_date AS field_merci_date_value, $column_end_date AS field_merci_date_value2 ,md.merci_item_nid FROM {" . $table . "} ct
      INNER JOIN {merci_reservation_detail} md on ct.vid = md.vid
      INNER JOIN {merci_bucket_node} m on md.merci_placeholder_nid = m.nid
      INNER JOIN {node} ctn on ct.vid = ctn.vid
      INNER JOIN {node} mn on m.vid = mn.vid
        WHERE (
                ($column_start_date >= '%s' and $column_start_date <= '%s')
            OR  ($column_end_date >= '%s' and $column_end_date <= '%s')
            OR  ($column_start_date <= '%s' and $column_end_date >= '%s')
          )
          AND mn.type = '%s'
          AND md.merci_item_nid !=0
          AND NOT md.merci_item_status <= %d
          $where",
    $args
  );

  // Use up items for assigned nodes.
  while ($node = db_fetch_object($reserved_nodes)) {
    // If item is assigned then item is in use by this node.
    $total_items_array[$node->merci_item_nid][$node->nid] = $node;
  }

  if ($overdue) {
    $overdue_items_array = merci_overdue_items($content_type, $start, $reservation_vid);

    if (!empty($overdue_items_array)) {
      foreach ($overdue_items_array as $merci_item_nid => $nodes) {
        foreach ($nodes as $nid => $node) {
          $total_items_array[$node->merci_item_nid][$node->nid] = $node;
        }
      }
    }
  }

  // pull reservations without assigned nodes and not status of MERCI_ITEM_STATUS_CHECKED_IN
  $reserved_nodes = db_query("
    SELECT ct.nid,$column_start_date AS field_merci_date_value, $column_end_date AS field_merci_date_value2 ,md.merci_item_nid FROM {" . $table . "} ct
        INNER JOIN {merci_reservation_detail} md ON ct.vid = md.vid
        INNER JOIN {merci_bucket_node} m ON md.merci_placeholder_nid = m.nid
        INNER JOIN {node} ctn on ct.vid = ctn.vid
        INNER JOIN {node} mn ON m.vid = mn.vid
          WHERE (
                  ($column_start_date >= '%s' AND $column_start_date <= '%s')
              OR  ($column_end_date >= '%s' AND $column_end_date <= '%s')
              OR  ($column_start_date <= '%s' AND $column_end_date >= '%s')
            )
            AND mn.type = '%s'
            AND md.merci_item_nid = 0
            AND NOT md.merci_item_status < %d
            $where",
    $args
  );

  uasort( $total_items_array, '_merci_sort_array');
  // Temporarily assign an item for these nodes.
  while ($node = db_fetch_object($reserved_nodes)) {

    // Eat up a bucket item for this node.
    // If item is not assigned then temporarily add one.
    foreach ($total_items_array as $item_nid => $reservations) {
      $willitfit = TRUE;
      foreach ($reservations as $oldnode) {
        // Does the start date overlap this reservation.
        if (
          (
            date_create($node->field_merci_date_value) > date_create($oldnode->field_merci_date_value) and
            date_create($node->field_merci_date_value) < date_create($oldnode->field_merci_date_value2)
          ) or
          // Does the end date overlap this reservation.
          (
            date_create($node->field_merci_date_value2) > date_create($oldnode->field_merci_date_value) and
            date_create($node->field_merci_date_value2) < date_create($oldnode->field_merci_date_value2)
          ) or
          // Does the start and end date overlap this reservation.
          (
            date_create($node->field_merci_date_value) <= date_create($oldnode->field_merci_date_value) and
            date_create($node->field_merci_date_value2) >= date_create($oldnode->field_merci_date_value2)
          )
        ) {
          // Can't use this item for this reservation. So try another.
          $willitfit = FALSE;
          break;
        }
      }
      if ($willitfit) {
        $total_items_array[$item_nid][$node->nid] = $node;
        break;
      }
    }
  }

  return $total_items_array;
}

// merci_get_reservable_items

/**
 * Calculates the total number of available bucket items for a reservation.
 *
 * @param $content_type
 *   The bucket content type.
 * @param $start
 *   Start time in DATETIME format UTC timezone.
 * @param $end
 *   End time in DATETIME format UTC timezone.
 * @param $reservation_nid
 *   (Optional) A reservation nid to exclude from the reserved items.
 *
 * @return
 *   The number of available bucket items.
 */
function merci_get_available_bucket_count($content_type, $start = NULL, $end = NULL, $reservation = NULL) {
  //if there are no dates, return the active total

  if (!$start) {

    //if user is admin/manager and merci template is installed

    $count = db_fetch_object(db_query("SELECT COUNT(n.nid) as total FROM {node} n
      LEFT JOIN {merci_bucket_node} mbn ON n.vid = mbn.vid
      WHERE n.type = '%s' AND n.status = 1
      AND mbn.merci_default_availability = 1",
      $content_type
    ));
    return $count->total;
  }

  $total_items_array = merci_reserved_bucket_items($content_type, $start, $end, $reservation );

  foreach ($total_items_array as $item_nid => $reservations) {
    if (!empty($reservations)) {
      $reserved_items++;
    }
  }

  return sizeof($total_items_array) - $reserved_items;
}

/**
 * merci_get_count ($content_type, $default_availability)
 * returns total number of items available for check out.
 * @ $content_type resource to be counted
 * @ $default_availability
 */

function merci_get_count($type, $default_availability = MERCI_AVA_F) {
  return db_result(db_query("SELECT COUNT(n.nid) as total FROM {node} n
      LEFT JOIN {merci_" . $type['merci_type_setting'] . "_node} mbn ON n.vid = mbn.vid
      WHERE n.type = '%s'
      AND mbn.merci_default_availability = %d
      AND mbn.merci_sub_type = %d",
      $type['type'], $default_availability, MERCI_SUB_TYPE_ITEM
    ));
}

/**
 * Builds an array representing reservations for a Resource within a given timespan
 *
 * @return
 *   An associative array with keys as times (in MySQL datetime format) and values as number of reservations.
 */
function merci_load_reservations_for_node_in_timespan($item_nid, $type, $start_date, $end_date, $reservation_vid = NULL) {

  // Determine CCK table and columns the date data is stored in.
  $field             = content_fields('field_merci_date');
  $db_info           = content_database_info($field);
  $table             = $db_info['table'];
  $column_start_date = $db_info['columns']['value']['column'];
  $column_end_date   = $db_info['columns']['value2']['column'];
  /*
   */

  $type_settings = merci_type_setting($type);
  if ($type_settings == 'bucket') {
    return merci_reserved_bucket_items($type, $start_date, $end_date, $reservation_vid);
  }
  else {
    $sql = "SELECT r.nid, $column_start_date AS field_merci_date_value, $column_end_date AS field_merci_date_value2, merci_item_nid
      FROM {node} n
      JOIN {merci_reservation_detail} d ON n.nid = d.merci_item_nid
      JOIN {" . $table . "} r ON d.vid = r.vid
      WHERE n.nid = %d
        AND
                    (($column_start_date >= '%s' AND $column_start_date <= '%s')
                    OR ($column_end_date >= '%s' AND $column_end_date <= '%s')
                    OR ($column_start_date <= '%s' AND $column_end_date >= '%s'))
      ";
  }

  $args = array($item_nid, $start_date, $end_date, $start_date, $end_date, $start_date, $end_date);

  // If we're checking an existing reservation, exclude it from the
  // reserved items.
  if ($reservation_vid) {
    $sql .= " AND d.vid <> %d";
    $args[] = $reservation_vid;
  }
  $sql .= " ORDER BY $column_start_date ";

  $reservations = db_query($sql, $args);
  while ($reservation = db_fetch_object($reservations)) {
    $return[$item_nid][$reservation->nid] = $reservation;
  }

  return $return;
}

/**
 * Does the very standard things that must be done in any normal callback.
 * Used by each callback in this example module.
 */
function merci_ahah_get_form() {
  // The form is generated in an include file which we need to include manually.
  include_once 'modules/node/node.pages.inc';
  $form_state = array(
    'storage' => NULL,
    'submitted' => FALSE,
  );
  //$form_state = array('storage' => TRUE, 'submitted' => TRUE);
  $form_build_id = $_POST['form_build_id'];
  $form = form_get_cache($form_build_id, $form_state);
  $args = $form['#parameters'];
  $form_id = array_shift($args);
  $form_state['post'] = $form['#post'] = $_POST;
  // Enable the submit/validate handlers to determine whether AHAH-submittted.
  $form_state['ahah_submission'] = TRUE;
  $form['#programmed'] = $form['#redirect'] = FALSE;
  // Stash original form action to avoid overwriting with drupal_rebuild_form().
  $form_state['action'] = $form['#action'];

  // Ripped off from drupal_process_form.  
  // We do the same except call validation.
  $form = form_builder($form_id, $form, $form_state);

  // We have to do this in order for the date_combo to be rebuilt properly.
  $element = $form['field_merci_date'][0];
  date_combo_validate($element, $form_state);

  // Continue ripping off drupal_proecss_form
  form_clean_id(NULL, TRUE);
  $form_state['redirect'] = NULL;
  form_execute_handlers('submit', $form, $form_state);

  // We'll clear out the cached copies of the form and its stored data
  // here, as we've finished with them. The in-memory copies are still
  // here, though.
  if (variable_get('cache', CACHE_DISABLED) == CACHE_DISABLED && !empty($form_state['values']['form_build_id'])) {
    cache_clear_all('form_' . $form_state['values']['form_build_id'], 'cache_form');
    cache_clear_all('storage_' . $form_state['values']['form_build_id'], 'cache_form');
  }

  // END ripping drupal_process_form.
  $form = drupal_rebuild_form($form_id, $form_state, $args, $form_build_id);
  // Clear any validation errors.  Only the date field is validated so this will clear the error so it won't
  // be outlined in red.
  form_set_error(NULL, '', TRUE);
  return array($form, $form_state);
}

function merci_ahah_output($selected_portion, $show_status = FALSE) {
  if ($show_status) {
    $output .= theme('status_messages');
  }
  // To avoid doubling-up the wrapper, we have to remove it here.
  if (is_array($selected_portion)) {
    unset($selected_portion['#prefix'], $selected_portion['#suffix']);

    //$output = theme('status_messages') . drupal_render($selected_portion);
    // BAD HACK to not show validation error messages for the date combo.  Not sure how to turn validation off for that.
    $output .= drupal_render($selected_portion);
  } else if (is_string($selected_portion)) {
    $output .= $selected_portion;
  }

  // Final rendering callback.
  drupal_json(array('status' => TRUE, 'data' => $output));

}

