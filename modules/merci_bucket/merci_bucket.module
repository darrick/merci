<?php

define('MERCI_BUCKET', 2);

function merci_bucket_merci_validate($entity_type, $entity, $field, $instance, $langcode, $target_id, &$error){
  $field_date_name = $field['settings']['handler_settings']['behaviors']['merci']['merci']['merci_date_field'];

  if (!property_exists($entity, $field_date_name)) {
    return;
  }
  $dates = merci_api_get_local_date_object($field_date_name, $entity->{$field_date_name}[$langcode][0]);
  $entity_items = entity_load($instance['entity_type'], array($target_id));
  $bucket_item = $entity_items[$target_id];
  if (!field_info_instance($instance['entity_type'], MERCI_TYPE_FIELD, $bucket_item->type)) {
    return;
  }
  $property = MERCI_TYPE_FIELD;
  $merci_type = $bucket_item->{$property}[$langcode][0]['value'];

  if ($merci_type != MERCI_BUCKET) {
    return;
  }

  $merci_bucket_field = 'field_bucket_items';

  $items = $bucket_item->{$merci_bucket_field}[$langcode];

  // Temp array to store all the bucket items tied to their reservations during the given time period.
  $bucket_items = array();


  // Reservations reserving the item directly.
  foreach ($items as $target) {
    // Is it available?
    $reservations = merci_api_check_conflicts($entity_type, $entity, $field, $target['target_id']);
    $bucket_items[$target['target_id']] = $reservations;
  }

  // Other bucket reservations.
  $bucket_reservations = merci_api_check_conflicts($entity_type, $entity, $field, $target_id);

  // Determine how many bucket items are needed for this time period.
  // Need to sort like this:
  //            .... time ....
  // item1  x x b b b x x x x x x x b b b x x x x x
  // item2  x x x b b b b b b x x x x b b b x x x x
  // item3  x x b b b b b b b b b b b b b x x x x x
  // etc ......
  //
  // I.e. For each conflict first see if it doesn't conflict with any reservation using item 1.  
  //      If it does test by using the next item.  
  //      If it doesn't then assign it that item.


  foreach ($bucket_reservations as $reservation_id => $reservation) {

    foreach ($bucket_items as $reserved_id => $conflicts) {

      $available = TRUE;

      foreach ($conflicts as $conflict) {
        // Does the start date overlap this reservation.
        if (
          (
            date_create($reservation->field_date_value) > date_create($conflict->field_date_value) and
            date_create($reservation->field_date_value) < date_create($conflict->field_date_value2)
          ) or
          // Does the end date overlap this reservation.
          (
            date_create($reservation->field_date_value2) > date_create($conflict->field_date_value) and
            date_create($reservation->field_date_value2) < date_create($conflict->field_date_value2)
          ) or
          // Does the start and end date overlap this reservation.
          (
            date_create($reservation->field_date_value) <= date_create($conflict->field_date_value) and
            date_create($reservation->field_date_value2) >= date_create($conflict->field_date_value2)
          )
        ) {
          // Can't use this item for this reservation. So try another.
          $available = FALSE;
          break;
        }
      // Check if this reservation conflicts with any existing reservations.
      }
      if ($available) {
        $bucket_items[$reserved_id][] = $reservation;
        break;
      }
    }
  }
  if ($max >= count($items)) {
    $error[] = array(
      'error' => 'merci_item_conflict',
      'message' => t('%name: the item cannot be reserved at this time.', array('%name' => $instance['label'])),
    );
  }
}

