<?php

/**
 * Implements hook_theme().
 */
function merci_selects_theme() {
  return array(
    'merci_selects_none' => array(
      'variables' => array('instance' => NULL, 'option' => NULL),
    ),
  );
}

/**
 * Returns HTML for the label for the empty value for options that are not required.
 *
 * The default theme will display N/A for a radio list and '- None -' for a select.
 *
 * @param $variables
 *   An associative array containing:
 *   - instance: An array representing the widget requesting the options.
 *
 * @ingroup themeable
 */
function theme_merci_selects_none($variables) {
  $instance = $variables['instance'];
  $option = $variables['option'];
  $output = ($option == 'option_none' ? t('- None -') : t('- Select a value -'));
  return $output;
}

/**
 * Implements hook_field_widget_info().
 *
 * Field type modules willing to use those widgets should:
 * - Use hook_field_widget_info_alter() to append their field own types to the
 *   list of types supported by the widgets,
 */
function merci_selects_field_widget_info() {
  return array(
    'merci_selects' => array(
      'label' => t('Merci Selects'),
      'field types' => array('entityreference'),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
        'default value' => FIELD_BEHAVIOR_NONE,
      ),
    ),
  );
}

/**
 * Implements hook_field_widget_form().
 */
function merci_selects_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  $widget = $instance['widget'];
  $settings = inline_entity_form_settings($field, $instance);
  $entity_info = entity_get_info($settings['entity_type']);
  $cardinality = $field['cardinality'];
  $controller = inline_entity_form_get_controller($instance);
  // The current entity type is not supported, execution can't continue.
  if (!$controller) {
    return array();
  }

  // Get the entity type labels for the UI strings.
  $labels = $controller->labels();

  // Build a parents array for this element's values in the form.
  $parents = array_merge($element['#field_parents'], array($element['#field_name'], $element['#language']));

  // Get the langcode of the parent entity.
  $parent_langcode = entity_language($element['#entity_type'], $element['#entity']);

  // Assign a unique identifier to each IEF widget.
  $ief_id = $instance['id'];
  // Determine the wrapper ID for the entire element.
  $wrapper = 'inline-entity-form-' . $ief_id;
  $element = array(
    '#type' => 'fieldset',
    '#tree' => TRUE,
    '#description' => NULL,
    '#prefix' => '<div id="' . $wrapper . '">',
    '#suffix' => '</div>',
    '#attached' => array(
      'css' => array(),
    ),
    '#ief_id' => $ief_id,
    '#ief_root' => TRUE,
  ) + $element;

  if (module_exists('file')) {
    // file.js triggers uploads when the main Submit button is clicked.
    $element['#attached']['js'] = array(
      drupal_get_path('module', 'file') . '/file.js',
      drupal_get_path('module', 'inline_entity_form') . '/inline_entity_form.js',
    );
  }

  $base_css = array(
    'base' => drupal_get_path('module', 'inline_entity_form') . '/theme/inline_entity_form.css',
    'seven' => drupal_get_path('module', 'inline_entity_form') . '/theme/inline_entity_form.seven.css',
  );
  // Add the base module CSS.
  _inline_entity_form_attach_css($base_css, $element['#attached']['css']);
  // Add entity type specific CSS.
  _inline_entity_form_attach_css($controller->css(), $element['#attached']['css']);

  // Initialize the IEF array in form state.
  if (empty($form_state['inline_entity_form'][$ief_id])) {
    $form_state['inline_entity_form'][$ief_id] = array(
      'form' => NULL,
      'settings' => $settings,
      'instance' => $instance,
    );

    // Load the entities from the $items array and store them in the form
    // state for further manipulation.
    $form_state['inline_entity_form'][$ief_id]['entities'] = array();
    $entity_ids = array();
    foreach ($items as $item) {
      $entity_ids[] = $item[$settings['column']];
    }

    $delta = 0;
    foreach (entity_load($settings['entity_type'], $entity_ids) as $entity) {
      $form_state['inline_entity_form'][$ief_id]['entities'][$delta] = array(
        'entity' => $entity,
        'weight' => $delta,
        'form' => NULL,
        'needs_save' => FALSE,
      );

      $delta++;
    }
  }

  // Build the appropriate widget.
  // The "Single value" widget assumes it is operating on a required single
  // value reference field with 1 allowed bundle.
  if ($widget['type'] == 'inline_entity_form_single') {
    // Intentionally not using $settings['create_bundles'] here because this
    // widget doesn't care about permissions because of its use case.
    $bundle = reset($settings['bundles']);

    // Uh oh, the parent entity type and bundle are the same as the inline
    // entity type and bundle. We have recursion. Abort.
    if ($element['#entity_type'] == $settings['entity_type'] && $element['#bundle'] == $bundle) {
      return array();
    }

    $form_state['inline_entity_form'][$ief_id]['form settings'] = array(
      'bundle' => $bundle,
    );

    $element['form'] = array(
      '#type' => 'container',
      '#op' => 'add',
      // Used by Field API and controller methods to find the relevant
      // values in $form_state.
      '#parents' => array_merge($parents, array('form')),
      // Pass the current entity type.
      '#entity_type' => $settings['entity_type'],
      // Pass the langcode of the parent entity,
      '#parent_language' => $parent_langcode,
      // Identifies the IEF widget to which the form belongs.
      '#ief_id' => $ief_id,
    );
    if (!empty($form_state['inline_entity_form'][$ief_id]['entities'])) {
      $element['form']['#op'] = 'edit';
      $element['form']['#entity'] = $form_state['inline_entity_form'][$ief_id]['entities'][0]['entity'];
      $element['form']['#ief_row_delta'] = 0;
    }

    $element['form'] = inline_entity_form_entity_form($controller, $element['form'], $form_state);
    // Hide all actions, the widget form behaves like a part of the main form.
    $element['form']['actions']['#access'] = FALSE;
  }
  else {
    // Build the "Multiple value" widget.
    $element['#element_validate'] = array('inline_entity_form_save_row_weights');

    $element['entities'] = array(
      '#tree' => TRUE,
      '#theme' => 'inline_entity_form_entity_table',
      '#entity_type' => $settings['entity_type'],
    );

    // Get the fields that should be displayed in the table.
    $fields = $controller->tableFields($settings['bundles']);
    $context = array(
      'parent_entity_type' => $instance['entity_type'],
      'parent_bundle' => $instance['bundle'],
      'field_name' => $instance['field_name'],
      'entity_type' => $settings['entity_type'],
      'allowed_bundles' => $settings['bundles'],
    );
    drupal_alter('inline_entity_form_table_fields', $fields, $context);
    $element['entities']['#table_fields'] = $fields;

    foreach ($form_state['inline_entity_form'][$ief_id]['entities'] as $key => $value) {
      // Data used by theme_inline_entity_form_entity_table().
      $element['entities'][$key]['#entity'] = $entity = $value['entity'];
      $element['entities'][$key]['#needs_save'] = $value['needs_save'];

      // Handle row weights.
      $element['entities'][$key]['#weight'] = $value['weight'];

      // First check to see if this entity should be displayed as a form.
      if (!empty($value['form'])) {
        $element['entities'][$key]['delta'] = array(
          '#type' => 'value',
          '#value' => $value['weight'],
        );
        $element['entities'][$key]['form'] = array(
          '#type' => 'container',
          '#attributes' => array('class' => array('ief-form', 'ief-form-row')),
          '#op' => $value['form'],
          // Used by Field API and controller methods to find the relevant
          // values in $form_state.
          '#parents' => array_merge($parents, array('entities', $key, 'form')),
          // Store the entity on the form, later modified in the controller.
          '#entity' => $entity,
          '#entity_type' => $settings['entity_type'],
          // Pass the langcode of the parent entity,
          '#parent_language' => $parent_langcode,
          // Identifies the IEF widget to which the form belongs.
          '#ief_id' => $ief_id,
          // Identifies the table row to which the form belongs.
          '#ief_row_delta' => $key,
        );
        // Prepare data for the form callbacks.
        $form = &$element['entities'][$key]['form'];

        // Add the appropriate form.
        if ($value['form'] == 'edit') {
          $form += inline_entity_form_entity_form($controller, $form, $form_state);
        }
        elseif ($value['form'] == 'remove') {
          $form += inline_entity_form_remove_form($controller, $form, $form_state);
        }
      }
      else {
        $row = &$element['entities'][$key];
        $row['delta'] = array(
          '#type' => 'weight',
          '#delta' => 50,
          '#default_value' => $value['weight'],
          '#attributes' => array('class' => array('ief-entity-delta')),
        );
        // Add an actions container with edit and delete buttons for the entity.
        $row['actions'] = array(
          '#type' => 'container',
          '#attributes' => array('class' => array('ief-entity-operations')),
        );

        // Make sure entity_access is not checked for unsaved entities.
        list($entity_id) = entity_extract_ids($controller->entityType(), $entity);
        if (empty($entity_id) || entity_access('update', $controller->entityType(), $entity)) {
          $row['actions']['ief_entity_edit'] = array(
            '#type' => 'submit',
            '#value' => t('Edit'),
            '#name' => 'ief-' . $ief_id . '-entity-edit-' . $key,
            '#limit_validation_errors' => array(),
            '#ajax' => array(
              'callback' => 'inline_entity_form_get_element',
              'wrapper' => $wrapper,
            ),
            '#submit' => array('inline_entity_form_open_row_form'),
            '#ief_row_delta' => $key,
            '#ief_row_form' => 'edit',
          );
        }

        // If 'allow_existing' is on, the default removal operation is unlink
        // and the access check for deleting happens inside the controller
        // removeForm() method.
        if (empty($entity_id) || $controller->getSetting('allow_existing')
          || entity_access('delete', $controller->entityType(), $entity)) {
          $row['actions']['ief_entity_remove'] = array(
            '#type' => 'submit',
            '#value' => t('Remove'),
            '#name' => 'ief-' . $ief_id . '-entity-remove-' . $key,
            '#limit_validation_errors' => array(),
            '#ajax' => array(
              'callback' => 'inline_entity_form_get_element',
              'wrapper' => $wrapper,
            ),
            '#submit' => array('inline_entity_form_open_row_form'),
            '#ief_row_delta' => $key,
            '#ief_row_form' => 'remove',
          );
        }
      }
    }

    $entity_count = count($form_state['inline_entity_form'][$ief_id]['entities']);
    if ($cardinality != FIELD_CARDINALITY_UNLIMITED) {
      // Return visual cue of cardinality count.
      $element['#description'] = t('You have added @entities_count out of @cardinality_count allowed @label.', array(
        '@entities_count' => $entity_count,
        '@cardinality_count' => $cardinality,
        '@label' => $labels['plural'],
      ));
    }
    // Do not return the rest of the form if cardinality count has been reached.
    if ($cardinality > 0 && $entity_count == $cardinality) {
      return $element;
    }

    // Try to open the add form (if it's the only allowed action, the
    // field is required and empty, and there's only one allowed bundle).
    if (empty($form_state['inline_entity_form'][$ief_id]['entities'])) {
      if (count($settings['create_bundles']) == 1 && $instance['required'] && !$controller->getSetting('allow_existing')) {
        $bundle = reset($settings['create_bundles']);

        // The parent entity type and bundle must not be the same as the inline
        // entity type and bundle, to prevent recursion.
        if ($element['#entity_type'] != $settings['entity_type'] || $element['#bundle'] != $bundle) {
          $form_state['inline_entity_form'][$ief_id]['form'] = 'add';
          $form_state['inline_entity_form'][$ief_id]['form settings'] = array(
            'bundle' => $bundle,
          );
        }
      }
    }

    // If no form is open, show buttons that open one.
    if (empty($form_state['inline_entity_form'][$ief_id]['form'])) {
      // Prepare the list of options.
      $value_key = key($field['columns']);
      $properties = _options_properties($type, $merci, $required, $has_value);

      $entity_type = $element['#entity_type'];
      $entity = $element['#entity'];
      $options = _merci_selects_get_options($field, $instance, $properties, $entity_type, $entity);

      $element['actions'] = array(
        '#attributes' => array('class' => array('container-inline')),
        '#type' => 'container',
        '#weight' => 100,
      );

      // The user is allowed to create an entity of at least one bundle.
      if (count($settings['create_bundles'])) {
        // Let the user select the bundle, if multiple are available.
        if (count($settings['create_bundles']) > 1) {
          $bundles = array();
          foreach ($entity_info['bundles'] as $bundle_name => $bundle_info) {
            if (in_array($bundle_name, $settings['create_bundles'])) {
              $bundles[$bundle_name] = $bundle_info['label'];
            }
          }

          $element['actions']['bundle'] = array(
            '#type' => 'select',
            '#options' => $options,
            '#value_key' => $value_key,
            '#properties' => $properties,
          );
        }
        else {
          $element['actions']['bundle'] = array(
            '#type' => 'value',
            '#value' => reset($settings['create_bundles']),
          );
        }

        $element['actions']['ief_add'] = array(
          '#type' => 'submit',
          '#value' => t('Reserve item'),
          '#name' => 'ief-' . $ief_id . '-add',
          '#limit_validation_errors' => array(array_merge($parents, array('actions'))),
          '#ajax' => array(
            'callback' => 'inline_entity_form_get_element',
            'wrapper' => $wrapper,
          ),
          '#submit' => array('inline_entity_form_open_form'),
          '#ief_form' => 'add',
        );
      }

      if ($controller->getSetting('allow_existing')) {
        $element['actions']['ief_add_existing'] = array(
          '#type' => 'submit',
          '#value' => t('Add existing @type_singular', array('@type_singular' => $labels['singular'])),
          '#name' => 'ief-' . $ief_id . '-add-existing',
          '#limit_validation_errors' => array(array_merge($parents, array('actions'))),
          '#ajax' => array(
            'callback' => 'inline_entity_form_get_element',
            'wrapper' => $wrapper,
          ),
          '#submit' => array('inline_entity_form_open_form'),
          '#ief_form' => 'ief_add_existing',
        );
      }
    }
    else {
      // There's a form open, show it.
      $element['form'] = array(
        '#type' => 'fieldset',
        '#attributes' => array('class' => array('ief-form', 'ief-form-bottom')),
        // Identifies the IEF widget to which the form belongs.
        '#ief_id' => $ief_id,
        // Used by Field API and controller methods to find the relevant
        // values in $form_state.
        '#parents' => array_merge($parents, array('form')),
        // Pass the current entity type.
        '#entity_type' => $settings['entity_type'],
        // Pass the langcode of the parent entity,
        '#parent_language' => $parent_langcode,
      );

      if ($form_state['inline_entity_form'][$ief_id]['form'] == 'add') {
        $element['form']['#op'] = 'add';
        $element['form'] += inline_entity_form_entity_form($controller, $element['form'], $form_state);

        // Hide the cancel button if the reference field is required but
        // contains no values. That way the user is forced to create an entity.
        if (!$controller->getSetting('allow_existing') && $instance['required']
          && empty($form_state['inline_entity_form'][$ief_id]['entities'])
          && count($settings['create_bundles']) == 1) {
          $element['form']['actions']['ief_add_cancel']['#access'] = FALSE;
        }
      }
      elseif ($form_state['inline_entity_form'][$ief_id]['form'] == 'ief_add_existing') {
        $element['form'] += inline_entity_form_reference_form($controller, $element['form'], $form_state);
      }

      // No entities have been added. Remove the outer fieldset to reduce
      // visual noise caused by having two titles.
      if (empty($form_state['inline_entity_form'][$ief_id]['entities'])) {
        $element['#type'] = 'container';
      }
    }
  }

  return $element;
}

/**
 * Implements hook_field_widget_form().
 */
/*
function merci_selects_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  
  // Abstract over the actual field columns, to allow different field types to
  // reuse those widgets.
  $value_key = key($field['columns']);
  $type = "select";
  $merci = 1;
  $required = $element['#required'];
  $has_value = isset($items[0][$value_key]);
  $properties = _options_properties($type, $merci, $required, $has_value);

  $entity_type = $element['#entity_type'];
  $entity = $element['#entity'];
  // Prepare the list of options.
  $options = _merci_selects_get_options($field, $instance, $properties, $entity_type, $entity);
  
  $widget = $element;

  $widget += array(
    '#type' => 'select',
    '#default_value' => isset($items[$delta][$value_key]) ? $items[$delta][$value_key] : NULL,
    '#options' => $options,
    '#element_validate' => array('merci_selects_widget_validate'),
    '#value_key' => $value_key,
    '#properties' => $properties,
  );
  $element[$value_key] = $widget;

  return $element;
}
 */
/**
 * Form element validation handler for options element.
 */
function merci_selects_widget_validate($element, &$form_state) {
  
  $value_key = $element['#value_key'];
  $properties = $element['#properties'];
  $value = $element['#value'];

  if ($element['#required'] && $element['#value'] == '_none') {
    form_error($element, t('!name field is required.', array('!name' => $element['#title'])));
  }
  
  if ($properties['empty_option']) {
    if ($value == '_none') {
      form_set_value($element, NULL, $form_state);
    }    
  }
  
}

/**
 * Implements hook_field_widget_error().
 */
function merci_selects_field_widget_error($element, $error, $form, &$form_state) {
  form_error($element, $error['message']);
}

/**
 * Collects the options for a field.
 */
function _merci_selects_get_options($field, $instance, $properties, $entity_type, $entity) {
  // Get the list of options.
  $options = (array) module_invoke($field['module'], 'options_list', $field, $instance, $entity_type, $entity);

  // Sanitize the options.
  _options_prepare_options($options, $properties);

  if (!$properties['optgroups']) {
    $options = options_array_flatten($options);
  }

  if ($properties['empty_option']) {
    $label = theme('merci_selects_none', array('instance' => $instance, 'option' => $properties['empty_option']));
    $options = array('_none' => $label) + $options;
  }

  return $options;
}
