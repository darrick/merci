<?php

// Reservation status options.
define('MERCI_STATUS_UNCONFIRMED', 1);
define('MERCI_STATUS_PENDING', 2);
define('MERCI_STATUS_CHECKED_OUT', 3);
define('MERCI_STATUS_CHECKED_IN', 4);
define('MERCI_STATUS_CANCELLED', 5);
define('MERCI_STATUS_DENIED', 6);
define('MERCI_STATUS_NO_SHOW', 7);

define('MERCI_STATUS_FIELD', 'field_merci_status');

/**
 * Add group and group content fields to new content types.
 *
 * @param $bundle_name
 *   The content type name.
 */
function merci_status_merci_node_type_save($bundle_name) {
  if (variable_get('merci_type_setting_' . $bundle_name, 'disabled') == MERCI_RESERVATION) {
    merci_create_field(MERCI_STATUS_FIELD, 'node', $bundle_name);
  }
}

/**
 * Implements hook_merci_fields_info().
 */
function merci_status_merci_fields_info() {
  $fields = array();

  $fields[MERCI_STATUS_FIELD] = array(
    'field' => array(
      'active' => '1',
      'cardinality' => '1',
      'deleted' => '0',
      'entity_types' => array(),
      'field_name' => MERCI_STATUS_FIELD,
      'foreign keys' => array(),
      'indexes' => array(
        'value' => array(
          0 => 'value',
        ),
      ),
      'locked' => '0',
      'module' => 'list',
      'settings' => array(
        'allowed_values' => array(
          MERCI_STATUS_UNCONFIRMED => 'Unconfirmed',
          MERCI_STATUS_PENDING => 'Pending',
          MERCI_STATUS_CHECKED_OUT => 'Checked out',
          MERCI_STATUS_CHECKED_IN => 'Checked in',
          MERCI_STATUS_CANCELLED => 'Canceled',
          MERCI_STATUS_DENIED => 'Denied',
          MERCI_STATUS_NO_SHOW => 'No show',
        ),
        'allowed_values_function' => '',
      ),
      'translatable' => '0',
      'type' => 'list_text',
    ),
    'instance' => array(
      'default_value' => array(
        0 => array(
          'value' => MERCI_STATUS_UNCONFIRMED,
        ),
      ),
      'deleted' => '0',
      'description' => '',
      'display' => array(
        'default' => array(
          'label' => 'above',
          'module' => 'list',
          'settings' => array(),
          'type' => 'list_default',
          'weight' => 2,
        ),
        'teaser' => array(
          'label' => 'above',
          'settings' => array(),
          'type' => 'hidden',
          'weight' => 0,
        ),
      ),
      'label' => 'Merci Status',
      'required' => 0,
      'settings' => array(
        'user_register_form' => FALSE,
      ),
      'widget' => array(
        'active' => 1,
        'module' => 'options',
        'settings' => array(),
        'type' => 'options_buttons',
        'weight' => '-2',
      ),
    ),
  );

  return $fields;
}
/**
 * Implements hook_permission().
 */
function merci_status_permission() {
  return array(
    'create confirmed reservations' => array(
      'title' => t('create confirmed reservations'),
      'description' => t('TODO Add a description for \'create confirmed reservations\''),
    ),
  );
}

/**
 * Implements hook_node_access().
 */
function merci_status_node_access($node, $op, $account) {

  if (is_merci_reservation_node($node)) {

    //users working with their own reservations access reservation
    //additional check in merci_form permission to edit confirmed reservations
    // Users without administer or manage reservations permission can only alter their own Unconfirmed Reservations.
    if (($op == 'delete' or $op == 'update') && isset($node->{MERCI_STATUS_FIELD})){
      if(user_access('create confirmed reservations')) {
        if ($node->{MERCI_STATUS_FIELD}['und'][0]['value'] > MERCI_STATUS_CONFIRMED) {
          return NODE_ACCESS_DENY;
        }
      } elseif ($node->{MERCI_STATUS_FIELD}['und'][0]['value'] != MERCI_STATUS_UNCONFIRMED) {
        return NODE_ACCESS_DENY;
      } 
    }
  }
  return NODE_ACCESS_IGNORE;
}

/**
 * Implementation of hook_node_operations().
 */
function merci_status_node_operations($return = NULL) {
  $operations = array(
    'merci_status_update' => array(
      'label' => t('Confirm Reservation(s)'),
      'callback' => 'merci_status_update',
    ),
  );
  return $operations;
}

/**
 * Callback function for updating Reservation status from VBO.
 */
function merci_status_update($nodes) {
  foreach ($nodes as $nid) {
    $node = node_load($nid);

    //only update if MERCI Status is Unconfirmed
    if ($node->{MERCI_STATUS_FIELD} == MERCI_STATUS_UNCONFIRMED) {
      $node->{MERCI_STATUS_FIELD} = MERCI_STATUS_PENDING;
      node_save($node);
    }
  }
}

/**
 * Callback function for updating Reservation status.
 */
function merci_confirm_reservation($nid) {
}

/*
 * Amend conflict query to only include conflicts if the reservation status is below MERCI_STATUS_CHECKED_IN
 */
function merci_status_merci_alter_conflict_query($entity, &$query) {
  if (!property_exists($entity, MERCI_STATUS_FIELD)) {
    return;
  }

  // Storage location for date field.
  $status_field_info = field_info_field(MERCI_STATUS_FIELD);
  $status_storage      = $status_field_info['storage']['details']['sql']['FIELD_LOAD_CURRENT'];
  $keys = array_keys($status_storage);
  $status_table        = reset($keys);
  $status_column  = $status_storage[$status_table]['value'];

  $query->join($status_table, 'status_table', 'item_table.entity_id = status_table.entity_id');
  $query->addField('status_table', $status_column, 'field_status_value');
  $query->condition($status_column, MERCI_STATUS_CHECKED_OUT, '<=');
}

function merci_status_gracetime() {
  $gracetime = NULL;
  return $gracetime;
}

function merci_status_field_attach_validate($entity_type, $entity, &$errors) {
  if (is_merci_reservation_node($entity)) {

    $merci_settings = merci_settings_load();
    $target_field = $merci_settings['target_field'];
    $date_field = $merci_settings['date_field'];
    $items = merci_api_extract_item_values($entity, $target_field);

    merci_status_merci_validate_items($entity_type, $entity, $date_field, $target_field, $items, &$errors);
  }
}
/**
 * Implementation of hook_validate().
 */
function merci_status_merci_validate_items($entity_type, $entity, $date_field, $target_field, $items, &$errors) {


  foreach ($items as $delta => $item) {
    $entity_ids[] = $item['target_id'];
  }

  $entity_items = entity_load($entity_type, $entity_ids);

  foreach ($items as $delta => $item) {
    if ($item['target_id']) {

      $gracetime = merci_status_gracetime();
      if($gracetime) {
        // TODO: add gracetime to startdate.
      }

      $conflicts = merci_status_check_overdue($entity_type, $entity, $date_field, $target_field, $item['target_id']);
      if (!empty($conflicts)) {
        // Ran out out of items to use for this reservation.
        $errors[$target_field][LANGUAGE_NONE][$delta][] = array(
          'error' => 'merci_item_conflict',
          'message' => t('%name: the item cannot be reserved at this time as it is overdue.', array('%name' => $entity_items[$item['target_id']]->title)),
        );
      }
    }
  }
}

/*
 * Check if $target_id and date field are unique.
 * i.e. Given a $entity of $entity_type with date field $field and entity reference $target_id ...
 * check to ensure no other entities reference the $target_id at the same time.
 */
function merci_status_check_overdue($entity_type, $entity, $date_field, $target_field, $target_id) {


  if (!property_exists($entity, MERCI_STATUS_FIELD) or !property_exists($entity, $date_field) or !property_exists($entity, $target_field)) {
    return;
  }
  // Get entity ids and language.
  list($entity_id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);
  $langcode = $entity->language ? $entity->language : LANGUAGE_NONE;


  // Storage location for date field.
  $date_field_info = field_info_field($date_field);
  $date_storage      = $date_field_info['storage']['details']['sql']['FIELD_LOAD_CURRENT'];
  $keys = array_keys($date_storage);
  $date_table        = reset($keys);
  $date_column  = $date_storage[$date_table]['value'];
  $date_column2 = $date_storage[$date_table]['value2'];

  $dates = $entity->{$date_field}[$langcode][0];
  // Storage location for target field.
  $item_field_info = field_info_field($target_field);
  $item_storage      = $item_field_info['storage']['details']['sql']['FIELD_LOAD_CURRENT'];
  $keys = array_keys($item_storage);
  $item_table        = reset($keys);
  $item_column  = $item_storage[$item_table]['target_id'];


  // Build the query.
  $query = db_select($item_table, 'item_table');
  $query->addField('item_table', 'entity_id', 'entity_id');

  $query->condition($item_column, $target_id);

  // Ignore myself.
  if ($entity_id) {
    $query->condition('item_table.entity_id', $entity_id, '!=');
  }

  $query->join($date_table, 'date_table', 'item_table.entity_id = date_table.entity_id');
  $query->addField('date_table', $date_column, 'field_date_value');
  $query->addField('date_table', $date_column2, 'field_date_value2');

  /* reservations in the past ... */
  $query->condition($date_column2, $dates['value'], '<=');

  // Storage location for date field.
  $status_field_info = field_info_field(MERCI_STATUS_FIELD);
  $status_storage      = $status_field_info['storage']['details']['sql']['FIELD_LOAD_CURRENT'];
  $keys = array_keys($status_storage);
  $status_table        = reset($keys);
  $status_column  = $status_storage[$status_table]['value'];

  $query->join($status_table, 'status_table', 'item_table.entity_id = status_table.entity_id');
  $query->addField('status_table', $status_column, 'field_status_value');
  $query->condition($status_column, MERCI_STATUS_CHECKED_OUT, '=');
  $query->orderBy($date_column, 'ASC');

  // Return any ids of conflicting reservations if any.
  return ($query->execute()->fetchAllAssoc('entity_id'));
}

